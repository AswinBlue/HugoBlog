---
title: "Exploit"
date: 2024-03-11T20:46:33+09:00
lastmod: 2024-03-11T20:46:33+09:00
tags: []
categories: []
imgs:  []
cover:  ""  # image show on top
readingTime:  true  # show reading time after article date
toc:  true
comments:  false
justify:  false  # text-align: justify;
single:  false  # display as a single page, hide navigation on bottom, like as about page.
license:  "BY-SA"  # CC License, https://creativecommons.org/licenses/?lang=ko
draft: false
---

# Exploit

## Shell Code
- exploit은 파일 읽고 쓰기(open-read-write, orw), 셸 명령 실행(execve) 권한을 취득하는 것을 목표로 한다.
- Shell 권한을 획득하기 위한 어셈블리 코드들의 모음을 'Shell Code' 라 칭한다.

### ORW
- 파일을 열고 읽고 쓸 수 있도록 하는 shell code를 'ORW shell code' 라 칭한다. 
- 시스템 콜들은 rax, rdi, rsi, rdx로 이루어 져 있음을 참고하여 shell code를 작성해 보자.
    - rax : 시스템 콜에 대응되는 번호
    - rdi : 시스템 콜의 첫 번째 인자
    - rsi : 시스템 콜의 두 번째 인자
    - rdx : 시스템 콜의 세 번째 인자
1. open
    - 리눅스에서 open 명령은 `open('FILE_PATH', flag, mode)` 형태이다. 
    - 이를 어셈블리어로 분리하여 표현하면 
        1) 'FILE_PATH' 을 stack에 담는다. 
            - 이때, stack에는 데이터가 8byte씩 올라가기 때문에 8byte 단위로 string을 끊어서 push한다.
            - ex) "1234567890" 을 stack에 담을 때 "09" "87654321" 순으로 데이터를 push해야 한다.
        2) rsp를 rdi로 옮겨  rdi(첫번째 인자)가 'FILE_PATH'를 가리키도록 한다.
        3) 두 번째와 세 번째 인자에 맞게 각각 rsi와 rdx를 설정한다.
        4) open은 시스템 콜 번호 2에 해당하므로 rax를 2로 설정한다.
    - ex) open ("1234567890", O_RDONLY, NULL) 은 아래 어셈블리어로 치환된다.
        ```
        push 0x3039
        push 0x3837363534333231
        mov rdi, rsp    ; (1) rdi = "1234567890"
        xor rsi, rsi    ; (3) rsi = 0 ; O_RDONLY
        xor rdx, rdx    ; (3) rdx = 0 ; NULL
        mov rax, 2      ; (4) rax = 2 ; syscall_open
        syscall         ; open("1234567890", O_RDONLY, NULL)
        ```

2. read
    - read 명령은 `read(FILE_DESCRIPTOR, buf, size)` 형태이다.
    - read 명령을 어셈블리어로 표현하면
      1) open을 통해 열린 파일의 file descriptor는 `rax` 영역에 저장되므로, `rax` 값을 `rdi` 에 대입한다.
      2) 데이터를 저장할 길이를 고려하여 `rsi`에 값을 대입한다. size가 10이라면 `rsp-10` 값을 대입한다.
      3) `rdx` 에 size 값을 대입한다.
      4) `rax` 에 read에 해당하는 0 값을 대입한다.
    - ex) read(fd, buf, 10) 은 아래 어셈블리어로 표현된다.
        ```
        mov rdi, rax      ; (1) fd값을 rdi에 대입
        mov rsi, rsp
        sub rsi, 0x0A     ; (2) rsi = rsp-10 ; buf
        mov rdx, 0x0A     ; (3) rdx = 0x0A     ; length
        mov rax, 0x0      ; (4) rax = 0        ; syscall_read
        syscall           ; read(fd, buf, 0x0A)
        ```
3. write
    - write 명령은 `write(FILE_DESCRIPTOR, buf, size)` 형태이다.
    - write 명령을 어셈블리어로 표현하면
        1) `rdi` 에 FILE_DESCRIPTOR 값을 대입한다. stdout으로 출력을 하려면 0x01을 적용한다.
        2) `rsi` 와 `rdx` 는 read 에서 사용한 값과 동일한 값을 적용한다.
        3) write 에 해당하는 시스템콜 번호 1을 `rax` 에 대입한다.
    - ex) write(fd, buf, 10) 은 아래 어셈블리어로 표현된다.
        ```
        mov rdi, 1        ; (1) rdi = 1 ; fd = stdout
                          ; rsi rdx 값은 read와 동일한 값 사용, 별도 설정 안함
        mov rax, 0x1      ; (3) rax = 1 ; syscall_write
        syscall           ; write(fd, buf, 0x0A)
        ```