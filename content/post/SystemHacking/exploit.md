---
title: "Exploit"
date: 2024-03-11T20:46:33+09:00
lastmod: 2024-03-11T20:46:33+09:00
tags: []
categories: []
imgs:  []
cover:  ""  # image show on top
readingTime:  true  # show reading time after article date
toc:  true
comments:  false
justify:  false  # text-align: justify;
single:  false  # display as a single page, hide navigation on bottom, like as about page.
license:  "BY-SA"  # CC License, https://creativecommons.org/licenses/?lang=ko
draft: false
---

# Exploit

## Shell Code
- exploit은 파일 읽고 쓰기(open-read-write, orw), 셸 명령 실행(execve) 권한을 취득하는 것을 목표로 한다.
- Shell 권한을 획득하기 위한 어셈블리 코드들의 모음을 'Shell Code' 라 칭한다.

### ORW
- 파일을 열고 읽고 쓸 수 있도록 하는 shell code를 'ORW shell code' 라 칭한다. 
- 시스템 콜들은 rax, rdi, rsi, rdx로 이루어 져 있음을 참고하여 shell code를 작성해 보자.
    - rax : 시스템 콜에 대응되는 번호
    - rdi : 시스템 콜의 첫 번째 인자
    - rsi : 시스템 콜의 두 번째 인자
    - rdx : 시스템 콜의 세 번째 인자
1. open
    - 리눅스에서 open 명령은 `open('FILE_PATH', flag, mode)` 형태이다. 
    - 이를 어셈블리어로 분리하여 표현하면 
        1) 'FILE_PATH' 을 stack에 담는다. 
            - 이때, stack에는 데이터가 8byte씩 올라가기 때문에 8byte 단위로 string을 끊어서 push한다.
            - ex) "1234567890" 을 stack에 담을 때 "09" "87654321" 순으로 데이터를 push해야 한다.
        2) rsp를 rdi로 옮겨  rdi(첫번째 인자)가 'FILE_PATH'를 가리키도록 한다.
        3) 두 번째와 세 번째 인자에 맞게 각각 rsi와 rdx를 설정한다.
        4) open은 시스템 콜 번호 2에 해당하므로 rax를 2로 설정한다.
    - ex) open ("1234567890", O_RDONLY, NULL) 은 아래 어셈블리어로 치환된다.
        ```
        push 0x3039
        mov rax, 0x3837363534333231 ; to push 8byte
        push rax
        mov rdi, rsp    ; (1) rdi = "1234567890"
        xor rsi, rsi    ; (3) rsi = 0 ; O_RDONLY
        xor rdx, rdx    ; (3) rdx = 0 ; NULL
        mov rax, 2      ; (4) rax = 2 ; syscall_open
        syscall         ; open("1234567890", O_RDONLY, NULL)
        ```

2. read
    - read 명령은 `read(FILE_DESCRIPTOR, buf, size)` 형태이다.
    - read 명령을 어셈블리어로 표현하면
      1) open을 통해 열린 파일의 file descriptor는 `rax` 영역에 저장되므로, `rax` 값을 `rdi` 에 대입한다.
      2) 데이터를 저장할 길이를 고려하여 `rsi`에 값을 대입한다. size가 10이라면 `rsp-10` 값을 대입한다.
      3) `rdx` 에 size 값을 대입한다.
      4) `rax` 에 read에 해당하는 0 값을 대입한다.
    - ex) read(fd, buf, 10) 은 아래 어셈블리어로 표현된다.
        ```
        mov rdi, rax      ; (1) fd값을 rdi에 대입
        mov rsi, rsp
        sub rsi, 0x0A     ; (2) rsi = rsp-10 ; buf
        mov rdx, 0x0A     ; (3) rdx = 0x0A     ; length
        mov rax, 0x0      ; (4) rax = 0        ; syscall_read
        syscall           ; read(fd, buf, 0x0A)
        ```
3. write
    - write 명령은 `write(FILE_DESCRIPTOR, buf, size)` 형태이다.
    - write 명령을 어셈블리어로 표현하면
        1) `rdi` 에 FILE_DESCRIPTOR 값을 대입한다. stdout으로 출력을 하려면 0x01을 적용한다.
        2) `rsi` 와 `rdx` 는 read 에서 사용한 값과 동일한 값을 적용한다.
        3) write 에 해당하는 시스템콜 번호 1을 `rax` 에 대입한다.
    - ex) write(fd, buf, 10) 은 아래 어셈블리어로 표현된다.
        ```
        mov rdi, 1        ; (1) rdi = 1 ; fd = stdout
                          ; rsi rdx 값은 read와 동일한 값 사용, 별도 설정 안함
        mov rax, 0x1      ; (3) rax = 1 ; syscall_write
        syscall           ; write(fd, buf, 0x0A)
        ```

- shell code는 어셈블리 형태이므로 기계어로 컴파일 해서 사용 가능하지만, 실행될 기기의 os, cpu에 따라 다른 방법을 사용해야 한다.
- shell code를 동작시키기 위해 skeleton code에 shell code를 삽입하여 컴파일 하는 방법을 사용할 수 있다. 
  - skeleton code란, 아무런 동작도 하지 않는 어셈블리어로 작성된 코드로, 컴파일이 가능하다. 
  - 마치 C언어에서 `void main(void) { return 0 }` 를 컴파일 하는 것과 같다. 
  - C언어로 작성된 skeleton code의 예시는 아래와 같다. 
  ```
    // 어셈블리어로 작성한 'assem_code' 함수를 실행시키는 파일
    __asm__(
        ".global assem_code\n"
        "assem_code:\n"

        # 여기에 원하는 assembly code를 집어넣는다.
        # 어셈블리 코드는 라인마다 마지막에 '\n' 가 붙어야 함에 주의한다.

        "xor rdi, rdi   # rdi = 0\n"
        "mov rax, 0x3c	# rax = sys_exit\n"
        "syscall        # exit(0)"
    );

    void assem_code();

    int main() { assem_code(); }
  ```
### execve
- execve() 는 Linux kernel 레벨의 함수로, 특정 프로그램을 실행시키는 함수이다. 
- `execve("/bin/bash", NULL, NULL)` 을 실행할 수 있게 되면 쉘을 실행할 수 있는 권한을 얻은 것이다. 
- execve는 `execve(FILE_NAME, argv, envp)` 형태로 실행되며, FILE_NAME은 실행할 프로그램 경로, argv는 인자, envp는 환경변수에 해당한다.
- execve를 어셈블리어로 표현하면
    1) 스택에 '/bin/bash' 를 넣고 `rdi`에 그 주소를 대입한다.
    2) `rsi`와 `rdx`는 NULL이므로 0을 대입한다. 
    3) execve는 시스템콜 번호 0x3B에 해당하므로 `rax`는 0x3B가 적용된다.
  ```
    push 0x68
    mov rax, 0x7361622f6e69622f
    push rax
    mov rdi, rsp  ; (1) rdi = "/bin/bash"
    xor rsi, rsi  ; (2) rsi = NULL
    xor rdx, rdx  ; (2) rdx = NULL
    mov rax, 0x3b ; (3) rax = execve
    syscall       ; execve("/bin/bash", null, null)
  ```

## 취약점
- 일반적으로 잘 알려진 취약점에 대해 서술한다.

### buffer overflow
- 프로그램에 입력을 위해 지정된 버퍼를 초과하여 입력값을 집어넣어 버퍼 다음에 할당된 메모리의 값을 덮어쓰는 행위
- `scanf("%s",buf)`는 입력값의 갯수 제한이 없기 때문에 buffer overflow에 취약하므로 절대 사용하면 안되는 형태 중 하나이다.
  - scanf와 유사하게 strcpy, strcat, sprintf 도 길이에 제약이 없는 함수로, 대신 strncpy, strncat, snprintf, fgets, memcpy 를 사용하는것이 권장된다.
- C 계열 언어에서 문자열(string)을 처리할 때 문자열의 종결을 null('\0') 문자로 판단하는데, 문자열 끝에 null이 존재하지 않는 경우 문자열보다 더 뒷편의 주소를 참조하게 될 수 있고, 이를 OOB(out of boundary) 취약점이라 한다.

### Stack Canary
- 광부들이 탄광에 들어갈 때 카나리아 새를 데리고 들어간다. 카나리아는 인간보다 가스에 민감하여, 유독가스로 인해 위험한 상황이 발생 할 경우 카나리아가 먼저 이를 인지하고 이상 행동을 보이게 된다. 광부들은 카나리아의 행동을 관찰하며 위험한 환경에서 빨리 탈출할 수 있다. 
- 탄광의 카나리아 새를 따서 Stack의 overflow를 감지하는 기능도 Stack Canary 라 이름 짓는다.
- 우분투에서 C 파일을 컴파일 할 때 기본적으로 Stack Canary를 적용하며, `-fno-stack-protector` 옵션을 넣어 gcc 컴파일을 하면 Stack Canary 설정을 끌 수 있다.
- Stack이 오염되면 대부분은 `Segmentation Fault` 오류를 발생하며 종료된다. 
- Stack Canary가 설정되어 있으면 `stack smashing detected` 오류가 대신 발생한다. 이는 Stack의 오염이 감지되어 강제로 프로그램이 종료됨을 의미한다.
- Stack Canary의 동작을 어셈블리어로 표현하면 다음과 같다.
    ```
    	mov    rax,QWORD PTR fs:0x28    # fs 레지스터의 0x28값을 rax에 대입
      mov    QWORD PTR [rbp-0x8],rax  # 스택 카나리를 rbp-8에 저장
      call   FUNCTION                 # 함수 호출

      ...

      mov    rcx,QWORD PTR [rbp-0x8]  # rbp-8에서 스택 카나리 추출
      xor    rcx,QWORD PTR fs:0x28    # fs:0x28과 스택 카나리 비교
      je     0x6f0 <main+94>          # 값이 같으면 다르면 호출부로 이동
      call   __stack_chk_fail@plt     # 값이 다르면 에러 출력

    ```
    - fs는 세그먼트 레지스터의 일종으로, 리눅스는 부팅시 fs:0x28 위치에 랜덤 생성하여 저장한다.
- X64 아키텍처는 8바이트, X86 아키텍처는 4바이트 카나리를 사용한다.
- 카나리는 NULL 값으로 시작한다.
- 카나리는 TLS에 전역변수로 저장되고, 각 함수들이 이를 공용으로 참조한다.

### NX
- No eXecute의 약자로, 실행에 사용되는 메모리 영역과 writing에 사용되는 메모리 영역을 분리하여 악의적으로 buffer에 코드를 심어 실행시키는 행위를 방지하는 기법이다.
- NX 기법은 CPU가 지원해야 동작할 수 있다.
- NX가 적용된 바이너리를 gdb로 디버깅 하여 `vmmap` 명령으로 각 주소의 권한을 살펴보면 `Perm` 영역이 'rw'와 'x' 가 분리된 것이 확인된다.
- 실행 권한이 없는 주소를 실행시키려 하면 segment fault 가 발생하며 코드가 종료되게 된다.
- NX기법은 XD(eXecution Disable), DEP(Data Execution Prevention), XN(eXecute Never) 등으로 불리기도 한다.

### ASLR
- Address Space Layout Randomization 의 약자로 바이너리가 실행 될 떄 마다 매번 다른 주소값에 메모리 세그먼트들을 할당하여 주소의 유출을 방지하는 기법이다.
- 커널에서 ASLR을 지원해야 동작이 가능하다.
- 리눅스에서 `cat /proc/sys/kernel/randomize_va_space` 명령으로 해당 커널이 ASLR을 지원하는지 확인 가능하다.
  - 0 : ASLR 미지원
  - 1 : stack, heap, library, vdso 등의 주소를 랜덤화
  - 2 : (1) 에 더해 brk 영역도 랜덤화
- 리눅스는 ASLR이 적용됐을 때, 페이지(page) 단위로 파일을 매핑하기 때문에 주소값 64비트 중 앞 52비트의 주소는 바뀌어도 뒤 12비트는 변경되지 않는다.
  - 0x1111111111111222 : 1은 변경될 수 있고, 2는 고정
  - 예를들어 라이브러리의 printf의 함수의 주소가 0x12345678이라면, 다음번 실행시에도 마지막 12비트는 678임이 보장된다.
- main 함수의 주소는 여러번 실행해도 변경되지 않는다.