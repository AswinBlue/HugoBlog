---
title: "Exploit"
date: 2024-03-11T20:46:33+09:00
lastmod: 2024-03-11T20:46:33+09:00
tags: []
categories: []
imgs:  []
cover:  ""  # image show on top
readingTime:  true  # show reading time after article date
toc:  true
comments:  false
justify:  false  # text-align: justify;
single:  false  # display as a single page, hide navigation on bottom, like as about page.
license:  "BY-SA"  # CC License, https://creativecommons.org/licenses/?lang=ko
draft: false
---

# Exploit
- `pwntool`의 `checksec` 명령어로 어떤 보안이 적용되었는지 확인 가능하다.


## Shell Code
- exploit은 파일 읽고 쓰기(open-read-write, orw), 셸 명령 실행(execve) 권한을 취득하는 것을 목표로 한다.
- Shell 권한을 획득하기 위한 어셈블리 코드들의 모음을 'Shell Code' 라 칭한다.

## 취약점 공격 기법

### ORW
- 파일을 열고 읽고 쓸 수 있도록 하는 shell code를 'ORW shell code' 라 칭한다. 
- 시스템 콜들은 rax, rdi, rsi, rdx로 이루어 져 있음을 참고하여 shell code를 작성해 보자.
    - rax : 시스템 콜에 대응되는 번호
    - rdi : 시스템 콜의 첫 번째 인자
    - rsi : 시스템 콜의 두 번째 인자
    - rdx : 시스템 콜의 세 번째 인자
1. open
    - 리눅스에서 open 명령은 `open('FILE_PATH', flag, mode)` 형태이다. 
    - 이를 어셈블리어로 분리하여 표현하면 
        1) 'FILE_PATH' 을 stack에 담는다. 
            - 이때, stack에는 데이터가 8byte씩 올라가기 때문에 8byte 단위로 string을 끊어서 push한다.
            - ex) "1234567890" 을 stack에 담을 때 "09" "87654321" 순으로 데이터를 push해야 한다.
        2) rsp를 rdi로 옮겨  rdi(첫번째 인자)가 'FILE_PATH'를 가리키도록 한다.
        3) 두 번째와 세 번째 인자에 맞게 각각 rsi와 rdx를 설정한다.
        4) open은 시스템 콜 번호 2에 해당하므로 rax를 2로 설정한다.
    - ex) open ("1234567890", O_RDONLY, NULL) 은 아래 어셈블리어로 치환된다.
        ```
        push 0x3039
        mov rax, 0x3837363534333231 ; to push 8byte
        push rax
        mov rdi, rsp    ; (1) rdi = "1234567890"
        xor rsi, rsi    ; (3) rsi = 0 ; O_RDONLY
        xor rdx, rdx    ; (3) rdx = 0 ; NULL
        mov rax, 2      ; (4) rax = 2 ; syscall_open
        syscall         ; open("1234567890", O_RDONLY, NULL)
        ```

2. read
    - read 명령은 `read(FILE_DESCRIPTOR, buf, size)` 형태이다.
    - read 명령을 어셈블리어로 표현하면
      1) open을 통해 열린 파일의 file descriptor는 `rax` 영역에 저장되므로, `rax` 값을 `rdi` 에 대입한다.
      2) 데이터를 저장할 길이를 고려하여 `rsi`에 값을 대입한다. size가 10이라면 `rsp-10` 값을 대입한다.
      3) `rdx` 에 size 값을 대입한다.
      4) `rax` 에 read에 해당하는 0 값을 대입한다.
    - ex) read(fd, buf, 10) 은 아래 어셈블리어로 표현된다.
        ```
        mov rdi, rax      ; (1) fd값을 rdi에 대입
        mov rsi, rsp
        sub rsi, 0x0A     ; (2) rsi = rsp-10 ; buf
        mov rdx, 0x0A     ; (3) rdx = 0x0A     ; length
        mov rax, 0x0      ; (4) rax = 0        ; syscall_read
        syscall           ; read(fd, buf, 0x0A)
        ```
3. write
    - write 명령은 `write(FILE_DESCRIPTOR, buf, size)` 형태이다.
    - write 명령을 어셈블리어로 표현하면
        1) `rdi` 에 FILE_DESCRIPTOR 값을 대입한다. stdout으로 출력을 하려면 0x01을 적용한다.
        2) `rsi` 와 `rdx` 는 read 에서 사용한 값과 동일한 값을 적용한다.
        3) write 에 해당하는 시스템콜 번호 1을 `rax` 에 대입한다.
    - ex) write(fd, buf, 10) 은 아래 어셈블리어로 표현된다.
        ```
        mov rdi, 1        ; (1) rdi = 1 ; fd = stdout
                          ; rsi rdx 값은 read와 동일한 값 사용, 별도 설정 안함
        mov rax, 0x1      ; (3) rax = 1 ; syscall_write
        syscall           ; write(fd, buf, 0x0A)
        ```

- shell code는 어셈블리 형태이므로 기계어로 컴파일 해서 사용 가능하지만, 실행될 기기의 os, cpu에 따라 다른 방법을 사용해야 한다.
- shell code를 동작시키기 위해 skeleton code에 shell code를 삽입하여 컴파일 하는 방법을 사용할 수 있다. 
  - skeleton code란, 아무런 동작도 하지 않는 어셈블리어로 작성된 코드로, 컴파일이 가능하다. 
  - 마치 C언어에서 `void main(void) { return 0 }` 를 컴파일 하는 것과 같다. 
  - C언어로 작성된 skeleton code의 예시는 아래와 같다. 
  ```
    // 어셈블리어로 작성한 'assem_code' 함수를 실행시키는 파일
    __asm__(
        ".global assem_code\n"
        "assem_code:\n"

        # 여기에 원하는 assembly code를 집어넣는다.
        # 어셈블리 코드는 라인마다 마지막에 '\n' 가 붙어야 함에 주의한다.

        "xor rdi, rdi   # rdi = 0\n"
        "mov rax, 0x3c	# rax = sys_exit\n"
        "syscall        # exit(0)"
    );

    void assem_code();

    int main() { assem_code(); }
  ```
### execve
- execve() 는 Linux kernel 레벨의 함수로, 특정 프로그램을 실행시키는 함수이다. 
- `execve("/bin/bash", NULL, NULL)` 을 실행할 수 있게 되면 쉘을 실행할 수 있는 권한을 얻은 것이다. 
- execve는 `execve(FILE_NAME, argv, envp)` 형태로 실행되며, FILE_NAME은 실행할 프로그램 경로, argv는 인자, envp는 환경변수에 해당한다.
- execve를 어셈블리어로 표현하면
    1) 스택에 '/bin/bash' 를 넣고 `rdi`에 그 주소를 대입한다.
    2) `rsi`와 `rdx`는 NULL이므로 0을 대입한다. 
    3) execve는 시스템콜 번호 0x3B에 해당하므로 `rax`는 0x3B가 적용된다.
  ```
    push 0x68
    mov rax, 0x7361622f6e69622f
    push rax
    mov rdi, rsp  ; (1) rdi = "/bin/bash"
    xor rsi, rsi  ; (2) rsi = NULL
    xor rdx, rdx  ; (2) rdx = NULL
    mov rax, 0x3b ; (3) rax = execve
    syscall       ; execve("/bin/bash", null, null)
  ```

### buffer overflow
- 프로그램에 입력을 위해 지정된 버퍼를 초과하여 입력값을 집어넣어 버퍼 다음에 할당된 메모리의 값을 덮어쓰는 행위
- `scanf("%s",buf)`는 입력값의 갯수 제한이 없기 때문에 buffer overflow에 취약하므로 절대 사용하면 안되는 형태 중 하나이다.
  - scanf와 유사하게 strcpy, strcat, sprintf 도 길이에 제약이 없는 함수로, 대신 strncpy, strncat, snprintf, fgets, memcpy 를 사용하는것이 권장된다.
- C 계열 언어에서 문자열(string)을 처리할 때 문자열의 종결을 null('\0') 문자로 판단하는데, 문자열 끝에 null이 존재하지 않는 경우 문자열보다 더 뒷편의 주소를 참조하게 될 수 있고, 이를 OOB(out of boundary) 취약점이라 한다.

### ROP(Return Oriented Programming)
- gadget이란 어셈블리어에서 ret 명령어 앞에 오는 코드 조각으로 코드의 실행을 제어한다.
- gadget 을 사용하여 함수의 호출 혹은 인자를 조작하는 공격 방식을 ROP라 한다.
- payload를 return gadget(리턴 가젯) 으로 채워지기에 ROP chain 이라고도 한다.

#### Return to Shellcode
- buffer overflow를 통해 버퍼에 shell 함수 실행 코드를 삽입하고 STL 에서 return 주소를 해당 버퍼의 주소로 치환하여 shell code를 실행하는 해킹 기법

#### Return To Library
- NX를 통해 특정 버퍼의 실행을 막자 library의 코드를 실행시켜서 쉘 권한을 얻는 방식의 해킹 기법
- 리눅스의 `libc` 라이브러리의 `system`, `execve` 함수를 실행시키는 것이 대표적이다.

#### Return to PLT
- ASLR 기법이 적용되어도 PLT의 주소는 고정되어 있음을 이용한 공격 방법 으로, PIE 기법을 적용하면 Return to PLT 공격을 예방할 수 있다.
- system 함수가 호출되고, canary가 유출되는 코드라면 아래 절차로 쉘을 실행시킬 수 있다.
  1. `system()` 이 호출 될 떄 rdi 를 반환하는 위치를 찾는다. rdi 값을 "/bin/sh"로 설정하게 된다면 system("/bin/sh"), 즉 쉘을 실행하게 되는 것이다.
    - ROPgadget 을 사용하여 `pop rdi` 구문의 주소를 찾는다. (여러 개 있다면 이중 system() 함수의 위치를 특정해야 한다.)
    - `ROPgadget --binary BINARY_FILE_PATH --re pop rdi` 를 입력하면 BINARY_FILE_PATH 경로의 바이너리에서 'pop rdi' 구문이 들어있는 gadget들을 출력한다.
  2.  `/bin/sh` 문자열이 저장된 주소를 확인한다.
    - gdb로 바이너리를 실행시킨 후 `search /bin/sh` 명령으로 확인 가능하다.
  3. `system` 함수의 PLT 주소를 확인한다. 
    - gdb로 바이너리를 실행시킨 후 `plt` 명령으로 `system@plt` 값의 주소를 확인한다. (`info func system@plt` 명령도 가능)
  4. 리턴 가젯의 주소를 확인한다.
    - `ROPgadget --binary BINARY_FILE_PATH --re ret` 명령중 ret 가 단독으로 있는 라인(리턴 가젯)의 주소를 확인한다.
    - `system()` 함수는 내부에서 movaps 함수를 사용하는데, x64 환경에서 이 함수는 스택에서 값을 읽어올 때 16바이트로 정렬되는지 확인하고, 16바이트로 묶어지지 않는다면 exception을 발생시켜 segment fault을 유발한다.
    - 이를 '리턴 가젯'을 스택에 집어넣어 8바이트를 추가하여 16바이트를 맞춘다.
      - exploit을 활용해 A 주소번지를 스택프레임에 return code 영역에 넣으려 할 때, 아래와 같이 return code 자리에 직접 A 주소를 집어넣어도 되지만,
        ```
        canary
        ---------- rbp
        SFP
        ---------- rbp + 0x8
        return code   <-- A 주소 주입
        ---------- rbp + 0x10
        ```
      - 아래 그림과 같이 return code 자리에 리턴 가젯을 주입해도 된다.
        ```
        canary
        ---------- rbp
        SFP
        ---------- rbp + 0x8
        return code <-- 리턴 가젯 주입  
        ---------- rbp + 0x10
        ???????     <-- A 주소 주입
        ```
      - 리턴가젯 `ret` 는 `pop rip; jmp rip` 와 같은 효과이고, 이는 결국 rbp + 0x10 위치에 있는 A 주소를 실행하게 되어 첫번째 코드와 동작성은 같다. 
      - 다만, return code 자리보다 8byte 아래쪽 주소를 사용하게 된다.
    - [MOVAPS 관련 참조 페이지](https://ropemporium.com/guide.html)
  5. buffer overflow를 활용해 `canary`를 복구하고, SFP를 아무 값으로 채운다. 
  6. `return code` 리턴 가젯으로 채워 rbp+0x10의 주소에 있는 코드가 실행되도록 한다. (system 함수의 movaps 에 대응하기 위함)
  7. rbp + 0x10 주소를 `pop rdi` 가젯으로 채우고, (2)에서 찾은 `/bin/sh` 주소를 집어넣고, (3) 에서 찾은 `system` 함수의 plt 주소를 그 다음에 집어넣는다.
    - 여기까지 수행하면 스택은 다음과 같다. 
     ```
        canary
        ---------- rbp
        SFP   <-- 랜덤값 주입
        ---------- rbp + 0x8
        return code <-- 리턴 가젯 주입  
        ---------- rbp + 0x10
        ???????     <-- pop rdi 가젯 주입
        ---------- rbp + 0x18
        ???????     <-- "/bin/sh" string 주소 주입
        ---------- rbp + 0x20
        ???????     <-- system() 함수 plt 주소 주입
        ```

#### Return Oriented Programming
- 앞서 살펴본 `Return to ~` 공격은 일부 방어 기법이 빠져있을 때 사용할 수 있었다. 
- 카나리, NX, ASLR이 모두 적용되어 있어도, 프로그램에 buffer overflow 취약점을 통해 exploit 을 수행하는 방법을 알아본다.
1. stack canary 주소 확인
   - `printf`, `write`, `puts` 등 버퍼를 출력하는 함수의 버퍼를 overflow 시켜 rbp-0x08 에 위치한 canary를 확인한다.
     - [stack참조](../../assembly/assembly_basic/#스택프레임)
2. system() 함수 주소 확인
   - `NX` 보호기법 때문에 코드를 직접 버퍼에 작성하고 실행시킬수 없기에 system("/bin/sh") 를 동작시키는 것을 목표로 한다.
   - `libc.so.6` 에 정의된 `system` 함수의 위치를 확인하기 위해 같은 라이브러리에 포함된 `read`, `puts`, `printf` 등의 함수가 호출되어 `GOT` 에 저장되었는지 확인한다. 
     - 라이브러리의 함수가 하나라도 호출되었다면, 라이브러리 파일 전체가 로드 되기 때문에 `syetem` 함수도 메모리에 적재 됨이 보장된다. 
     - ASLR을 통해 라이브러리 파일의 적재 위치를 랜덤화 시켰지만, 라이브러리 파일 내부의 함수 위치는 랜덤화 시키지 못한다. 
     - 즉, `libc` 라이브러리 안에서 `puts` 함수의 주소와 `puts` 함수와 `system` 함수 주소 사이의 거리는 항상 일치한다는 것이다. 
     - `GOT` 를 확인하여 `libc` 파일 안의 `puts` 함수의 메모리 주소를 안다면, `system` 함수의 주소를 확인할 수 있다. 

### Hook Overwrite
- `__libc_malloc` 함수를 살펴보면 `__malloc_hook` 함수가 있으면 이를 호출하도록 되어 있다. `__malloc_hook` 는 `libc.so` 영역 안에 있으므로 writing 권한이 있는 라이브러리 영역이며, 이를 원하는 형태로 덮어써서 수행하는 공격을 Hook Overwrite 라 한다.


## 보호 기법
- 앞서 살펴본 취약점을 방어하기 위한 기법들을 소개한다.

### Stack Canary
- 광부들이 탄광에 들어갈 때 카나리아 새를 데리고 들어간다. 카나리아는 인간보다 가스에 민감하여, 유독가스로 인해 위험한 상황이 발생 할 경우 카나리아가 먼저 이를 인지하고 이상 행동을 보이게 된다. 광부들은 카나리아의 행동을 관찰하며 위험한 환경에서 빨리 탈출할 수 있다. 
- 탄광의 카나리아 새를 따서 Stack의 overflow를 감지하는 기능도 Stack Canary 라 이름 짓는다.
- 우분투에서 C 파일을 컴파일 할 때 기본적으로 Stack Canary를 적용하며, `-fno-stack-protector` 옵션을 넣어 gcc 컴파일을 하면 Stack Canary 설정을 끌 수 있다.
- Stack이 오염되면 대부분은 `Segmentation Fault` 오류를 발생하며 종료된다. 
- Stack Canary가 설정되어 있으면 `stack smashing detected` 오류가 대신 발생한다. 이는 Stack의 오염이 감지되어 강제로 프로그램이 종료됨을 의미한다.
- Stack Canary의 동작을 어셈블리어로 표현하면 다음과 같다.
    ```
    	mov    rax,QWORD PTR fs:0x28    # fs 레지스터의 0x28값을 rax에 대입
      mov    QWORD PTR [rbp-0x8],rax  # 스택 카나리를 rbp-8에 저장
      call   FUNCTION                 # 함수 호출

      ...

      mov    rcx,QWORD PTR [rbp-0x8]  # rbp-8에서 스택 카나리 추출
      xor    rcx,QWORD PTR fs:0x28    # fs:0x28과 스택 카나리 비교
      je     0x6f0 <main+94>          # 값이 같으면 다르면 호출부로 이동
      call   __stack_chk_fail@plt     # 값이 다르면 에러 출력

    ```
    - fs는 세그먼트 레지스터의 일종으로, 리눅스는 부팅시 fs:0x28 위치에 랜덤 생성하여 저장한다.
- X64 아키텍처는 8바이트, X86 아키텍처는 4바이트 카나리를 사용한다.
- stack에 적용될 때 x64 아키텍처는 8바이트, x86 아키텍처는 4바이트 더미값 이후 canary가 들어감에 주의한다.
  - [stack참조](../../assembly/assembly_basic/#스택프레임)
- 카나리는 NULL 값으로 시작한다.
- 카나리는 TLS에 전역변수로 저장되고, 각 함수들이 이를 공용으로 참조한다.

### NX
- No eXecute의 약자로, 실행에 사용되는 메모리 영역과 writing에 사용되는 메모리 영역을 분리하여 악의적으로 buffer에 코드를 심어 실행시키는 행위를 방지하는 기법이다.
- NX 기법은 CPU가 지원해야 동작할 수 있다.
- NX가 적용된 바이너리를 gdb로 디버깅 하여 `vmmap` 명령으로 각 주소의 권한을 살펴보면 `Perm` 영역이 'rw'와 'x' 가 분리된 것이 확인된다.
- 실행 권한이 없는 주소를 실행시키려 하면 segment fault 가 발생하며 코드가 종료되게 된다.
- NX기법은 XD(eXecution Disable), DEP(Data Execution Prevention), XN(eXecute Never) 등으로 불리기도 한다.

### ASLR
- Address Space Layout Randomization 의 약자로 바이너리가 실행 될 떄 마다 매번 다른 주소값에 메모리 세그먼트들을 할당하여 주소의 유출을 방지하는 기법이다.
- 커널에서 ASLR을 지원해야 동작이 가능하다.
- 리눅스에서 `cat /proc/sys/kernel/randomize_va_space` 명령으로 해당 커널이 ASLR을 지원하는지 확인 가능하다.
  - 0 : ASLR 미지원
  - 1 : stack, heap, library, vdso 등의 주소를 랜덤화
  - 2 : (1) 에 더해 brk 영역도 랜덤화
- 리눅스는 ASLR이 적용됐을 때, 페이지(page) 단위로 파일을 매핑하기 때문에 주소값 64비트 중 앞 52비트의 주소는 바뀌어도 뒤 12비트는 변경되지 않는다.
  - 0x1111111111111222 : 1은 변경될 수 있고, 2는 고정
  - 예를들어 라이브러리의 printf의 함수의 주소가 0x12345678이라면, 다음번 실행시에도 마지막 12비트는 678임이 보장된다.
- main 함수의 주소는 여러번 실행해도 변경되지 않는다.

### PIE
- Position Independent Executable 의 약자이다.
- ASLR이 런타임에 생성되는 stack, heap, library 영역의 메모리를 랜덤 매핑하는 기법이었다면, PIE는 code 영역의 메모리를 랜덤하게 매핑하는 보호 기법이다.

### RELRO (RELocation Read-Only)
- 데이터 세그먼트에서 불필요한 쓰기 권한을 제거하여 공격을 방지하는 방법
- Partial RELRO 와 Full RELRO 두 가지 방법이 있다.
  - gcc 컴파일 시 `-no-pie -fno-pie` 옵션을 넣어서 pie를 제거하면 partial RELRO 로 동작한다.
  - `-no-pie`는 코드 생성 옵션이고, `-fno-pie`는 링킹 과정의 옵션으로 둘 다 설정해야 PIE 없이 바이너리가 생성된다.
  - 위 두 옵션 없이 gcc 컴파일을 수행하면 Full RELRO가 적용된다.
- Partial RELRO 가 적용된 파일을 `objdump -h` 명령어로 확인하면 section에 `.got`와 `.got.plt` 가 확인된다.
  - `.got` section에는 실행되기 전에 바인딩 되는 전역변수들이 저장되며 쓰기 권한이 없다.
  - `.got.plt` section에는 실행되는 도중 바인딩 되는 전역변수들이 저장되며 쓰기 권한이 부여된다. 
  - `.got.plt` 영역을 덮어쓰는 `GOT overwrite` 공격에 취약하다.
- Full RELRO 가 적용되면 함수들의 주소가 바이너리 로딩 시점에 모두 바인딩 되므로 .got 영역에는 쓰기 권한이 부여되지 않는다.
  - 동적 메모리 할당/해제시 동작하는 `hook` 을 이용한 공격인 `Hook Overwrite` 에 취약하다.

#### segment 권한 확인 방법
1. 특정 프로세스에서 `/proc/self/maps` 경로의 파일을 출력하도록 코드를 작성한다.
2. 작성한 코드를 컴파일 하고, 실행 파일을 생성한다.
3. 실행 파일을 실행하여 `/proc/self/maps` 파일 내용을 확인한다.
  - 내용 중 `파일명` 에 해당하는 부분이 메모리 시작주소이다. 
  - ex) `objdump -h /usr/bin/cat` 결과이다. /usr/bin/cat의 메모리 시작주소는 0x561210c55000 가 된다.
    ```
    561210c55000-561210c57000 r--p 00000000 08:20 1773                       /usr/bin/cat
    561210c57000-561210c5c000 r-xp 00002000 08:20 1773                       /usr/bin/cat
    561210c5c000-561210c5f000 r--p 00007000 08:20 1773                       /usr/bin/cat
    561210c5f000-561210c60000 r--p 00009000 08:20 1773                       /usr/bin/cat
    561210c60000-561210c61000 rw-p 0000a000 08:20 1773                       /usr/bin/cat
    5612123c3000-5612123e4000 rw-p 00000000 00:00 0                          [heap]
    7f84ddb0a000-7f84ddb2c000 rw-p 00000000 00:00 0
    7f84ddb2c000-7f84ddb5e000 r--p 00000000 08:20 25559                      /usr/lib/locale/C.UTF-8/LC_CTYPE
    7f84ddb5e000-7f84ddb5f000 r--p 00000000 08:20 25620                      /usr/lib/locale/C.UTF-8/LC_NUMERIC
    7f84ddb5f000-7f84ddb60000 r--p 00000000 08:20 26418                      /usr/lib/locale/C.UTF-8/LC_TIME
    7f84ddb60000-7f84ddcd3000 r--p 00000000 08:20 25554                      /usr/lib/locale/C.UTF-8/LC_COLLATE
    7f84ddcd3000-7f84ddcd4000 r--p 00000000 08:20 25593                      /usr/lib/locale/C.UTF-8/LC_MONETARY
    7f84ddcd4000-7f84ddcd5000 r--p 00000000 08:20 25575                      /usr/lib/locale/C.UTF-8/LC_MESSAGES/SYS_LC_MESSAGES
    7f84ddcd5000-7f84ddcd6000 r--p 00000000 08:20 26123                      /usr/lib/locale/C.UTF-8/LC_PAPER
    7f84ddcd6000-7f84ddcd7000 r--p 00000000 08:20 25601                      /usr/lib/locale/C.UTF-8/LC_NAME
    7f84ddcd7000-7f84ddfbd000 r--p 00000000 08:20 15009                      /usr/lib/locale/locale-archive
    7f84ddfbd000-7f84ddfdf000 r--p 00000000 08:20 42427                      /usr/lib/x86_64-linux-gnu/libc-2.31.so
    7f84ddfdf000-7f84de157000 r-xp 00022000 08:20 42427                      /usr/lib/x86_64-linux-gnu/libc-2.31.so
    7f84de157000-7f84de1a5000 r--p 0019a000 08:20 42427                      /usr/lib/x86_64-linux-gnu/libc-2.31.so
    7f84de1a5000-7f84de1a9000 r--p 001e7000 08:20 42427                      /usr/lib/x86_64-linux-gnu/libc-2.31.so
    7f84de1a9000-7f84de1ab000 rw-p 001eb000 08:20 42427                      /usr/lib/x86_64-linux-gnu/libc-2.31.so
    7f84de1ab000-7f84de1b1000 rw-p 00000000 00:00 0
    7f84de1b1000-7f84de1b2000 r--p 00000000 08:20 25549                      /usr/lib/locale/C.UTF-8/LC_ADDRESS
    7f84de1b2000-7f84de1b3000 r--p 00000000 08:20 26189                      /usr/lib/locale/C.UTF-8/LC_TELEPHONE
    7f84de1b3000-7f84de1b4000 r--p 00000000 08:20 25574                      /usr/lib/locale/C.UTF-8/LC_MEASUREMENT
    7f84de1b4000-7f84de1bb000 r--s 00000000 08:20 42694                      /usr/lib/x86_64-linux-gnu/gconv/gconv-modules.cache
    7f84de1bb000-7f84de1bc000 r--p 00000000 08:20 42407                      /usr/lib/x86_64-linux-gnu/ld-2.31.so
    7f84de1bc000-7f84de1df000 r-xp 00001000 08:20 42407                      /usr/lib/x86_64-linux-gnu/ld-2.31.so
    7f84de1df000-7f84de1e7000 r--p 00024000 08:20 42407                      /usr/lib/x86_64-linux-gnu/ld-2.31.so
    7f84de1e7000-7f84de1e8000 r--p 00000000 08:20 25569                      /usr/lib/locale/C.UTF-8/LC_IDENTIFICATION
    7f84de1e8000-7f84de1e9000 r--p 0002c000 08:20 42407                      /usr/lib/x86_64-linux-gnu/ld-2.31.so
    7f84de1e9000-7f84de1ea000 rw-p 0002d000 08:20 42407                      /usr/lib/x86_64-linux-gnu/ld-2.31.so
    7f84de1ea000-7f84de1eb000 rw-p 00000000 00:00 0
    7ffcf0c34000-7ffcf0c55000 rw-p 00000000 00:00 0                          [stack]
    7ffcf0d14000-7ffcf0d18000 r--p 00000000 00:00 0                          [vvar]
    7ffcf0d18000-7ffcf0d1a000 r-xp 00000000 00:00 0                          [vdso]
    ```
4. 생성한 실행파일을 `objdump -h` 명령어를 사용해 section header를 확인한다.
  - section header의 VMA에 해당하는 부분이 메모리의 offset이다. (3)에서 찾은 메모리 시작주소에 offset을 더하면 실제 메모리 주소를 확인할 수 있다.
  - ex) `.plt` 의 메모리 주소는 0x561210c55000 + 0x0000000000002020 = `0x561210C57020` 가 된다.
    ```
    /usr/bin/cat:     file format elf64-x86-64

    Sections:
    Idx Name          Size      VMA               LMA               File off  Algn
    0 .interp       0000001c  0000000000000318  0000000000000318  00000318  2**0
                    CONTENTS, ALLOC, LOAD, READONLY, DATA
    1 .note.gnu.property 00000020  0000000000000338  0000000000000338  00000338  2**3
                    CONTENTS, ALLOC, LOAD, READONLY, DATA
    2 .note.gnu.build-id 00000024  0000000000000358  0000000000000358  00000358  2**2
                    CONTENTS, ALLOC, LOAD, READONLY, DATA
    3 .note.ABI-tag 00000020  000000000000037c  000000000000037c  0000037c  2**2
                    CONTENTS, ALLOC, LOAD, READONLY, DATA
    4 .gnu.hash     0000006c  00000000000003a0  00000000000003a0  000003a0  2**3
                    CONTENTS, ALLOC, LOAD, READONLY, DATA
    5 .dynsym       00000690  0000000000000410  0000000000000410  00000410  2**3
                    CONTENTS, ALLOC, LOAD, READONLY, DATA
    6 .dynstr       0000033d  0000000000000aa0  0000000000000aa0  00000aa0  2**0
                    CONTENTS, ALLOC, LOAD, READONLY, DATA
    7 .gnu.version  0000008c  0000000000000dde  0000000000000dde  00000dde  2**1
                    CONTENTS, ALLOC, LOAD, READONLY, DATA
    8 .gnu.version_r 00000060  0000000000000e70  0000000000000e70  00000e70  2**3
                    CONTENTS, ALLOC, LOAD, READONLY, DATA
    9 .rela.dyn     00000378  0000000000000ed0  0000000000000ed0  00000ed0  2**3
                    CONTENTS, ALLOC, LOAD, READONLY, DATA
    10 .rela.plt     00000498  0000000000001248  0000000000001248  00001248  2**3
                      CONTENTS, ALLOC, LOAD, READONLY, DATA
    11 .init         0000001b  0000000000002000  0000000000002000  00002000  2**2
                      CONTENTS, ALLOC, LOAD, READONLY, CODE
    12 .plt          00000320  0000000000002020  0000000000002020  00002020  2**4
                      CONTENTS, ALLOC, LOAD, READONLY, CODE
    13 .plt.got      00000010  0000000000002340  0000000000002340  00002340  2**4
                      CONTENTS, ALLOC, LOAD, READONLY, CODE
    14 .plt.sec      00000310  0000000000002350  0000000000002350  00002350  2**4
                      CONTENTS, ALLOC, LOAD, READONLY, CODE
    15 .text         00003dc2  0000000000002660  0000000000002660  00002660  2**4
                      CONTENTS, ALLOC, LOAD, READONLY, CODE
    16 .fini         0000000d  0000000000006424  0000000000006424  00006424  2**2
                      CONTENTS, ALLOC, LOAD, READONLY, CODE
    17 .rodata       0000122c  0000000000007000  0000000000007000  00007000  2**5
                      CONTENTS, ALLOC, LOAD, READONLY, DATA
    18 .eh_frame_hdr 000002bc  000000000000822c  000000000000822c  0000822c  2**2
                      CONTENTS, ALLOC, LOAD, READONLY, DATA
    19 .eh_frame     00000ce8  00000000000084e8  00000000000084e8  000084e8  2**3
                      CONTENTS, ALLOC, LOAD, READONLY, DATA
    20 .init_array   00000008  000000000000aa90  000000000000aa90  00009a90  2**3
                      CONTENTS, ALLOC, LOAD, DATA
    21 .fini_array   00000008  000000000000aa98  000000000000aa98  00009a98  2**3
                      CONTENTS, ALLOC, LOAD, DATA
    22 .data.rel.ro  00000198  000000000000aaa0  000000000000aaa0  00009aa0  2**5
                      CONTENTS, ALLOC, LOAD, DATA
    23 .dynamic      000001f0  000000000000ac38  000000000000ac38  00009c38  2**3
                      CONTENTS, ALLOC, LOAD, DATA
    24 .got          000001c8  000000000000ae28  000000000000ae28  00009e28  2**3
                      CONTENTS, ALLOC, LOAD, DATA
    25 .data         000000c0  000000000000b000  000000000000b000  0000a000  2**5
                      CONTENTS, ALLOC, LOAD, DATA
    26 .bss          00000198  000000000000b0c0  000000000000b0c0  0000a0c0  2**5
                      ALLOC
    27 .gnu_debuglink 00000034  0000000000000000  0000000000000000  0000a0c0  2**2
                      CONTENTS, READONLY
    ```
5. (4)에서 확인한 메모리 주소가 (3)에서 출력한 메모리 주소별 권한을 대조하여, 해당 영역의 권한을 확인할 수 있다.
  - .plt 영역인 `0x561210C57020` 는 
  `561210c57000-561210c5c000 r-xp 00002000 08:20 1773                       /usr/bin/cat` 라인에 해당하며, 읽기/실행 권한이 있는 영역이다.
  - 쓰기 권한이 부여되지 않은 것이 확인된다. 
  - checksec 명령으로 확인 결과 Full RELRO가 적용된 것이 확인된다.
    ```
    checksec /usr/bin/cat
    [*] '/usr/bin/cat'
      Arch:     amd64-64-little
      RELRO:    Full RELRO
      Stack:    Canary found
      NX:       NX enabled
      PIE:      PIE enabled
      FORTIFY:  Enabled
    ```