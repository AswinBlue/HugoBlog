<!DOCTYPE html>
<html lang="en"><meta charset="utf-8"><meta name="generator" content="Hugo 0.87.0" /><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<meta name="color-scheme" content="light dark">
<meta name="supported-color-schemes" content="light dark"><title>React basic&nbsp;&ndash;&nbsp;AsWindBlew</title><link rel="stylesheet" href="/css/core.min.df05809cfa75ea0a430dc942a79e54236823f6be194b5bc34f0c64744ba5a1b55f91020ad551b34b8af7f2ebee758cc8.css" integrity="sha384-3wWAnPp16gpDDclCp55UI2gj9r4ZS1vDTwxkdEulobVfkQIK1VGzS4r38uvudYzI"><meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="React basic" /><body><section id="header">
    <div class="header wrap"><span class="header left-side"><a class="site home" href="/"><span class="site name">AsWindBlew</span></a></span>
        <span class="header right-side"><div class="nav wrap"><nav class="nav"><a class="nav item" href="/categories/">Categories</a><a class="nav item" href="/tags/">Tags</a><a class="nav item" href="/about/">About</a><a class="nav item" href="https://gohugo%2eio/"target="_blank">Hugo</a></nav></div></span></div><div class="site slogan"><span class="title">published by AswinBlue</span></div></section><section id="content"><div class="article-container"><section class="article header">
    <h1 class="article title">React basic</h1><p class="article date">Aug 23, 2021<span class="reading-time"> • 10 minutes to read</span></p></section><article class="article markdown-body"><h1 id="react-basic">React basic</h1>
<h2 id="개발환경-설치-및-실행">개발환경 설치 및 실행</h2>
<ol>
<li>node.js 로 만들어진 create-react-app 툴을 이용하면 손쉽게 react 앱을 생성할 수 있다.</li>
</ol>
<ul>
<li>npm을 설치하고 아래 명령어를 수행하여 create-react-app을 설치한다.
<code>npm install -g create-react-app</code></li>
</ul>
<ol start="2">
<li>원하는 경로에 들어가 프로젝트를 생성한다.</li>
</ol>
<ul>
<li><code>create-react-app &lt;NAME&gt;</code> : NAME 경로에 프로젝트 생성</li>
<li>주의 : 프로젝트가 생성되는 폴더명은 대문자를 사용할 수 없다.</li>
</ul>
<ol start="3">
<li>실행</li>
</ol>
<ul>
<li><code>npm run start</code> 를 수행하면 <code>localhost:3000</code>에서 웹페이지를 퍼블리싱한다.</li>
</ul>
<h2 id="기본-구조">기본 구조</h2>
<ol>
<li>/public/index.html 에서 기본 화면 구성</li>
</ol>
<ul>
<li>&lsquo;root&rsquo; 이름으로 된 division이 있는데, 이 division에 대한 설정은 javascript로 정의되어있다.</li>
</ul>
<ol start="2">
<li>src 경로에 javascript파일들 구성</li>
</ol>
<ul>
<li>&lsquo;index.js&rsquo; 에 메인 화면에 사용된 객체가 정의되어 있다. 아래 내용은 id가 &lsquo;root&rsquo; 인 division에 &lsquo;App&rsquo;을 적용하겠다는 의미이다.</li>
</ul>
<pre><code>ReactDOM.render(
  &lt;React.StrictMode&gt;
    &lt;App /&gt;
  &lt;/React.StrictMode&gt;,
  document.getElementById('root')
);
</code></pre><ul>
<li>&lsquo;index.js&rsquo;에서 <code>&lt;App/&gt;</code> 라 되어있는 사용자 정의 태그를 생성했는데, <code>App</code>은 &lsquo;App.js&rsquo;에 정의되어 있고, &lsquo;index.js&rsquo;에서 &lsquo;App.js&rsquo;를 참조한다.</li>
<li>&lsquo;App.js&rsquo;에서 선언된 &lsquo;App&rsquo; 이라는 이름의 함수가 반환하는 값이 &lsquo;App&rsquo;태그에 치환된다고 보면 된다.</li>
<li>&lsquo;App&rsquo;이 함수가 아니라 class로 정의되어 있다면 &lsquo;App&rsquo; class의 &lsquo;render()&rsquo; 함수의 리턴값이 &lsquo;App&rsquo;태그로 치환된다.</li>
<li>리턴값은 무조건 특정 태그 안에 들어가 있어야 한다. <div>태그로 감싸주도록 한다.</li>
</ul>
<ol start="3">
<li>src경로에 css파일 구성</li>
</ol>
<ul>
<li>
<table>
<thead>
<tr>
<th>index.css에서 css설정 구성</th>
</tr>
</thead>
</table>
</li>
</ul>
<h2 id="배포">배포</h2>
<ul>
<li><code>npm run start</code>로 &lsquo;create-react-app&rsquo;으로 만든 앱을 실행시킬 수는 있지만, 이는 개발자용 실행 방식이다.</li>
<li>웹 브라우저에서 페이지에 접속하고 다운로드받은 용량을 확인해보면 아무 기능이 없어도 MB단위가 다운받아짐을 확인할 수 있다.</li>
<li>이러한 상태로 배포를 하면 효율 및 보안 관점에서 적합하지 않다.</li>
<li><code>npm run build</code> 명령어를 수행하면 &lsquo;build&rsquo;라는 새로운 디렉터리와 데이터들이 생성된다.</li>
<li>&lsquo;build&rsquo; 안에 있는 파일들은 공백 등을 제거하여 용량 및 보안에 최적화된 상태로 제공된다.</li>
<li>배포시에는 &lsquo;build&rsquo;디렉터리 안의 내용을 사용하면 된다. 웹서버의 최상위 디렉터리를 &lsquo;build&rsquo;로 설정하면 된다.</li>
<li><code>npm install serve</code> 명령어로 serve 툴을 설치한다. serve는 웹서버를 실행시키는 도구이다.</li>
<li><code>serve -s build</code> 명령어로 &lsquo;build&rsquo; 디렉터리를 root 디렉터리로 웹서버를 실행한다.</li>
<li>보통은 이렇게 일일이 작업을 수행하지 않고, <code>npm run deploy</code> 명령으로 package.json 파일에 기록된 설정대로 배포 작업을 자동화시킨다.</li>
</ul>
<h3 id="github에-배포">github에 배포</h3>
<ol>
<li>create-react-app으로 프로젝트 생성 : <code>create-react-app &lt;NAME&gt;</code></li>
<li>gh-pages 설치(이미 설치시 생략가능) : <code>npm install -g gh-pages</code></li>
<li>git hub에서 원하는 이름으로 repository 생성( 이후 {repo-name} 로 지칭)</li>
</ol>
<ul>
<li>생성된 git repository와 react 폴더 연동한다.</li>
<li><code>git init</code></li>
<li><code>git remote add origin {your-repository-url}</code></li>
</ul>
<ol start="4">
<li>package.json파일 수정 ({username}은 github 계정 이름)</li>
</ol>
<ul>
<li>&ldquo;homepage&rdquo; : &ldquo;http://{username}.github.io/{repo-name}&rdquo;</li>
<li>&ldquo;scripts&rdquo;: {&ldquo;predeploy&rdquo;: &ldquo;npm run build&rdquo;, &ldquo;deploy&rdquo;: &ldquo;gh-pages -d build&rdquo;}</li>
</ul>
<ol start="5">
<li>배포를 실행한다. <code>npm run deploy</code></li>
</ol>
<ul>
<li>gh-pages 라는 branch를 자동으로 생성하고, package.json에 설정한 &lsquo;homepage&rsquo; 주소에 react 페이지가 업로드된 것을 볼 수 있다.</li>
</ul>
<h2 id="문법">문법</h2>
<h3 id="함수">함수</h3>
<ol>
<li>일반 함수</li>
</ol>
<ul>
<li>javascript와 동일하게 선언 가능하다.</li>
</ul>
<pre><code>function Subject() {
    return (
	    &lt;div&gt;
        &lt;a href=&quot;/&quot; onClick={ function(e) {
          e.preventDefault();
          this.props.onChangePage();  // 상위 컴퍼넌트로 부터 받은 함수 실행
        }
		&lt;/div&gt;
	);
</code></pre><ol start="2">
<li>arrow 함수</li>
</ol>
<ul>
<li><code>FUNCTION_NAME = (VARIABLES) =&gt; { BODY }</code> 형태로 이루어져 있다.</li>
<li>VARIABLES는 &lsquo;,&lsquo;로 나누어져 두개 이상의 인자를 선언할 수 있고, BODY에서 사용될 수 있다.</li>
<li>위 함수를 호출하려면 <code>FUNCTION_NAME(VARIABLES)</code> 형태로 호출 가능하다.</li>
</ul>
<pre><code>highlightSquares = i =&gt; {
  if (this.props.winningSquares.length &gt; 0) {
    if (this.props.winningSquares.indexOf(i) &gt; -1) {
      return &quot;square winningSquares&quot;;
    } else {
      return &quot;square&quot;;
    }
  } else {
    return &quot;square&quot;;
  }
};
</code></pre><h3 id="변수">변수</h3>
<ul>
<li>hoisting : javascript에서는 변수를 scope(함수 혹은 블록)의 가장 위로 끌어올려서, 먼저 선언된것처럼 인식하는 기능이 있다.</li>
</ul>
<ol>
<li>var</li>
</ol>
<ul>
<li>var는 function-scoped 변수이다. 함수가 끝나기까지 해당 변수는 유지된다. (hoisting)</li>
<li>var를 block-scoped로 낮추기 위해서는 IIFE, &lsquo;use strict&rsquo; 등의 방법을 사용할 수도 있지만 let으로 선언하는게 빠르다.</li>
</ul>
<pre><code>function TEST() {
  for (var i = 0; i &lt; 10; i++) {
    console.log('i: ', i); // 정상출력
  }
  console.log('i: ', i); // 정상출력
}
console.log('i: ', i); // 오류
</code></pre><ul>
<li>동일한 이름의 변수를 재선언할 수 있고, hoisting에 의해 나중에 선언한 변수를 먼저 사용할수도 있다. (오류를 일으키기 좋은 허용이다)</li>
</ul>
<pre><code>var A = 1
var A = 2 // 가능

str='abcd' // 가능
var str
</code></pre><ol start="2">
<li>let</li>
</ol>
<ul>
<li>es2015에서 추가된 문법</li>
<li>재선언 불가능</li>
<li>hoisting 동작 안함</li>
</ul>
<pre><code>let A = 1
let A = 2 // 불가능
A = 3 // 가능

str='abcd' // 불가능
let str
</code></pre><ol start="3">
<li>const</li>
</ol>
<ul>
<li>es2015에서 추가</li>
<li>선언과 동시에 값 할당 필요, 재정의 불가능</li>
<li>hoisting 동작 안함</li>
</ul>
<pre><code>const A = 1
const A = 2 // 불가능
A = 3 // 불가능

str='abcd' // 불가능
const str // 불가능
</code></pre><ol start="4">
<li>선언없이 정의</li>
</ol>
<ul>
<li>아무 타입을 붙이지 않고 선언하면 전역변수로 선언된다.</li>
</ul>
<pre><code>str='12345'
A=5
</code></pre><h3 id="배열">배열</h3>
<ul>
<li>배열은 <code>arr=[1, 2, 3]</code> 과 같은 형태로 선언한다. <code>arr=[,,,]</code>과 같이 크기3(쉼표개수)의 배열 선언도 가능하지만, 배열의 요소는 undefined로 정의된다. <code>arr = new Array(1,2,3)</code>로 선언도 가능하다.</li>
<li>배열의 길이는 <code>arr.length</code> 로 추출 가능하다.</li>
<li>좌항에 배열 형태를 두어 배열의 요소를 각각 정의할 수 있다. <code> [a, b, c] = [1, 2, 3]</code> 이때, 일부 값을 무시할 수 있다. <code>[a, , c] = [1, 2, 3]</code></li>
<li>전개 연산자(&rsquo;&hellip;')을 이용하여 나머지 개체들을 통틀어 지정할 수 있다. <code>[a, b, ...c] = [1, 2, 3, 4, 5] // a = 1, b = 2, c = [3, 4, 5]</code></li>
<li>전개 연산자 이후 다른 변수가 오면 오류가 난다. <code>[a, b, ...c, d] = [1,2,3,4,5] // 오류</code></li>
<li>선언된 변수를 전개연산자로 다른 변수에 넣을수도 있다.</li>
<li><code>ARRAY.indexOf(ITEM)</code> : ARRAY 배열안의 ITEM의 index를 반환한다.</li>
</ul>
<pre><code>var A = [1, 2, 3, 4, 5]
var B = [...A] // B = [1, 2, 3, 4, 5]
</code></pre><h4 id="반복순회">반복(순회)</h4>
<ul>
<li>배열 내용을 순회하는 방법은 다음과 같다.</li>
</ul>
<ol>
<li>map 함수</li>
</ol>
<pre><code>var A = [1,2,3]
A.map((a) =&gt; {
  // 원하는 동작을 입력하면 된다.
})
A.map(Math.sqrt) // lambda함수 외 일반함수를 넣어도 된다.
</code></pre><ol start="2">
<li>for-of</li>
</ol>
<pre><code>var A = [1,2,3]
for (var a of A) {
  // java의 for( : ) 와 같다
}
</code></pre><ul>
<li>객체의 배열도 동일한 방법으로 순회가 가능하다. 다만 비구조화(destructing)가 포함된다.</li>
</ul>
<pre><code>var B = [{a:1, b:2, c:3}, {a:4, b:5, c:6}]
B.map({a,b,c} =&gt; {
  // 원하는 동작 수행
})
for (var {a:aa, b:bb, c:cc} of B) {
  // key가 마음에들지 않으면 재정의도 가능하다.
}
</code></pre><h4 id="비교">비교</h4>
<ul>
<li>filter 함수를 이용하여 조건에 맞는 요소만 선택 가능하다.</li>
</ul>
<pre><code>var a = [1,2,3,4,5,6,7]
var b = a.filter(i =&gt; i &lt; 4); // b = [1,2,3]
</code></pre><h3 id="객체">객체</h3>
<ul>
<li>Json형태로 이루어져 있다. <code>var obj = {'a':10, b:20}</code> key값은 &lsquo;&lsquo;를 붙여도 되고 안붙여도 된다.</li>
<li>value를 변수로 추출할때는 다음과 같이 수행한다. 이를 비구조화라 한다. <code>var {a,b,c} = {a:1, b:2, c:3} // a==1, b==2, c==3</code></li>
<li>비구조화시 기본값을 설정할 수도 있다. <code>var {a=1,b=2} = {a:10} // a==10, b==2. b=2를 설정하지 않으면 b==undefined</code></li>
<li>다른 key를 사용하고싶다면 다음과 같이 수행한다. <code>var {a:one, b:two} = {a:10, b:20, c:30} // one==10, two==20, c==30</code></li>
<li>key값으로 사용불가능한 값이 올 경우 다음과 같이 비구조화 한다. <code>var {'a-b-c':a_b_c, [key]:A_B_C} = {'a-b-c':10, 'A B C':20} // a_b_c = 10, A_B_C = 20</code></li>
<li>재구조화시 전개 연산자를 사용할 수 있지만, 전개연산자는 재정의할 수 없다. <code>{a:A, ...rest} = {a:10, b:20, c:30} // rest:B 는 불가능</code></li>
</ul>
<h3 id="복사">복사</h3>
<ul>
<li>배열</li>
</ul>
<pre><code>var a = [1,2,3]
var b = [...a] // 깊은복사
var [...c] = a // 깊은복사
var d = a // 얕은복사
</code></pre><ul>
<li>객체</li>
</ul>
<pre><code>var A = {one:1, two:2, three:3}
var B = {...A} // 깊은복사 : one==1, two==2, three==3
var C = {...A, three:30} // 깊은복사+값 할당 : one==1, two==2, three==30
</code></pre><h2 id="component">Component</h2>
<ol>
<li>js파일에서 컴포넌트를 생성하여 html에 적용</li>
</ol>
<ul>
<li>&lsquo;Subject&rsquo;라는 이름의 component를 생성해 본다.</li>
<li>생성된 &lsquo;Subject&rsquo;는 custom tag가 된다. HTML에서 tag를 호출하듯 사용 가능하다.</li>
</ul>
<ol>
<li>class형태로 만들기</li>
</ol>
<pre><code>class Subject extends Component {
   render() {
	   return (
		   &lt;header&gt;
         &lt;h1&gt;Hello&lt;/h1&gt;
       &lt;/header&gt;
     );
   }
}
</code></pre><ol start="2">
<li>함수 형태로 만들기</li>
</ol>
<pre><code>function Subject() {
    return (
	    &lt;div&gt;
		    &lt;h1&gt;Hello&lt;/h1&gt;
		  &lt;/div&gt;
	  );
}
</code></pre><p>-&gt; 함수형은 자원을 덜 사용하고, 선언하기 쉬운 장점이 있다.</p>
<ul>
<li>&lsquo;index.js&rsquo;가 default라 가정하고, &lsquo;App.js&rsquo;에서 App 객체 안에 <code>&lt;Subject&gt;&lt;/Subject&gt;</code> 와 같이 태그를 생성한다. (다른 파일에 선언했다면 해당 파일을 &lsquo;App.js&rsquo;에서 참조 필요)<br>
※  <em>&lsquo;App.js&rsquo; 파일은 확장자가 js이지만 코드 문법은 javascript가 아니다.</em></li>
</ul>
<h3 id="props">props</h3>
<ul>
<li>props를 활용하여 js파일에서 컴포넌트 태그 생성시 속성을 설정 가능하다.<br>
<code>&lt;Subject title=&quot;TITLE&quot;, content=&quot;CONTENT&quot;&gt;</code> : title 값으로 &ldquo;TITLE&rdquo;, content 값으로 &ldquo;CONTENT&rdquo; 설정</li>
<li>Subject 객체 생성시 <code>{this.prop.title}</code>, <code>{this.prop.content}</code>와 같이 참조하여 사용한다.</li>
</ul>
<pre><code>function Subject() {
    return (
	    &lt;div&gt;
		    &lt;h1&gt;{this.prop.title}&lt;/h1&gt;
        &lt;h2&gt;{this.prop.content}&lt;/h2&gt;
		&lt;/div&gt;
	);
}
</code></pre><ul>
<li>응용하여 아래와 같은 활용도 가능하다.</li>
</ul>
<pre><code>function Subject() {
    {title, content} = {this.prop}
    return (
	    &lt;div&gt;
		    &lt;h1&gt;{title}&lt;/h1&gt;
        &lt;h2&gt;{content}&lt;/h2&gt;
		&lt;/div&gt;
	);
}
</code></pre><h3 id="state">state</h3>
<ul>
<li>props는 부모 컴퍼넌트가 자식에게 설정해 주는 값이라면, state는 컴퍼넌트가 자기 자신을 위해 사용하는 값이다.</li>
<li>state는 함수형에서는 사용 불가능하고 클래스형에서 사용 가능하다. 대신 함수형에서는 &lsquo;훅&rsquo; 이라는 기능을 이용해 state와 유사한 효과를 낼 수 있다.</li>
</ul>
<ol>
<li>state 세팅</li>
</ol>
<ul>
<li>constructor : 컴퍼넌트가 생성되었을 때 최초로 실행되는 함수. 초기화를 담당한다.</li>
</ul>
<pre><code>class App extends Component {
  constructor(props) {
    super(props);       // constructor 함수 기본
    this.state : {    // state 초기화
      subject:{title:&quot;TITLE&quot;, content: &quot;CONTENT&quot;}
    }
  }
  render() {
    return (
      &lt;div ClassName = &quot;APP&quot;&gt;
        &lt;Subject title={this.state.subject.title} content={this.state.subject.content}&gt;&lt;/Subject&gt;     // html형태의 return값 안에서 javascript문법을 사용하려면 '{}'로 묶어준다.
      &lt;/div&gt;
    );
  }
}
</code></pre><p>-&gt; App 컴퍼넌트가 생성되면 초기 설정된 state 값으로 Subject 컴퍼넌트를 생성한다.</p>
<ul>
<li>index.js -&gt; App.js -&gt; Subject.js 순으로 호출이 이루어지는데, index.js에서는 App.js의 상태값을 알지 못한다. 즉, 부모에게 자신의 정보를 노출하지 않고 은닉한다.</li>
</ul>
<ol start="2">
<li>state로 배열 사용</li>
</ol>
<pre><code>  class App extends Component {
    constructor(props) {
      super(props);       // constructor 함수 기본
      this.state = {    // state 초기화
        subject:{title:&quot;TITLE&quot;, content: &quot;CONTENT&quot;},
        contents:[
          {id:1, title:'title1', desc:'desc1'},
          {id:2, title:'title2', desc:'desc2'},
          {id:3, title:'title3', desc:'desc3'},
        ]
      }
    }
    render() {
      return (
        &lt;div ClassName = &quot;APP&quot;&gt;
          &lt;TOC data={this.state.contents}&gt;&lt;/TOC&gt;
        &lt;/div&gt;
      );
    }
  }

  class TOC extends Component {
    render() {
      var lists = [];
      var data = this.props.data;
      var i = 0;
      while (i &lt; data.length) {
        lists.push(&lt;li key={i}&gt;&lt;a href={&quot;/content/&quot; + data[i].id}&gt;{data[i].title}&lt;/a&gt;&lt;/li&gt;)
        /*
         * 반복문을 통해 여러 객체를 만들 때, react에서는 'key'라는 유니크한 속성을 요구한다.
         *
         */
        i = i + 1;
      }
      return (
        &lt;nav&gt;
          &lt;ul&gt;
            {lists} // lists에 &lt;li&gt;태그들을 넣어놓은 것들이 그대로 출력된다.
          &lt;/ul&gt;
        &lt;/nav&gt;
      );
    }
  }
</code></pre><p>※ react에서는 props나 state가 바뀌면, 이를 사용하는 하위 컴퍼넌트들의 <code>render()</code> 함수가 모두 다시 호출된다. 즉, 화면이 재구성된다.</p>
<ol start="3">
<li>조건문</li>
</ol>
<ul>
<li><code>render()</code> 함수 안에서 javascript로 조건문 설정 가능</li>
</ul>
<pre><code>  class App extends Component {
    constructor(props) {
      super(props);       // constructor 함수 기본
      this.state = {    // state 초기화
        mode: 'read'
    }
    render() {
      var _mode = state.mode;
      if (_mode == 'read') {    // 조건문

      } else if (_mode == 'write') {

      }
      return (
        &lt;div ClassName = &quot;APP&quot;&gt;
          &lt;TOC data={this.state.contents}&gt;&lt;/TOC&gt;
        &lt;/div&gt;
      );
    }
  }
</code></pre><ol start="4">
<li>이벤트</li>
</ol>
<ol>
<li>onClick</li>
</ol>
<ul>
<li>html에서 onclick은 &lsquo;C&rsquo;가 소문자이지만, react에서는 대문자이다.</li>
<li>onClick은 인자로 함수를 받는다.
<ul>
<li>인자로 들어가는 함수는 &lsquo;event&rsquo; 객체를 인자로 받는다.</li>
<li>이 함수를 이벤트 함수라 한다.</li>
</ul>
</li>
</ul>
<pre><code>      class App extends Component {
        constructor(props) {
          super(props);  
          this.state = {}
        }
        render() {
          return (
            &lt;div&gt;
              &lt;a href=&quot;/&quot; onClick={function(e) {
                console.log(e);       // 로그 찍는 방법
                e.preventDefault();   // 해당 태그의 기본 클릭동작을 수행하지 않도록 한다.
                // 'a' 태그의 경우 링크로 접속하는 동작을 막는다.
                }
              }&gt;Click_here&lt;/a&gt;        
            &lt;/div&gt;
          );
        }
      }
</code></pre><ul>
<li>이벤트 함수 안에서는 기본적으로 &lsquo;this&rsquo;를 호출해도 아무것도 bind되어있지 않다.</li>
<li><code>onClick={function(e) { ... }.bind(this)}</code> 와 같이 this를 bind해주면 this를 사용할 수 있게된다.</li>
<li>이벤트 함수 안에서 <code>this.state.mode='write'</code>와 같이 state를 변경하면 react가 변경 여부를 확인하지 못해 render()함수를 다시 호출하지 않아 화면이 갱신되지 않는다.<br>
<code>this.setState({mode:'write'});</code>와 같이 state를 수정하도록 하자.</li>
</ul>
<p>+) bind</p>
<ul>
<li>이벤트 함수는 기본적으로 &lsquo;this&rsquo;를 가지지 않는다.</li>
<li>이때 강제로 this를 주입시키는 함수가 bind이다.</li>
</ul>
<pre><code>  var obj = {name:'obj'};
  functiotn bindTest() {
    console.log(this.name);
  }
  bindTest(); // 아무 반응이 없다.
  bindTest.bind(obj); // obj가 bindTest의 this가 된다.
</code></pre><ol start="2">
<li>custom event</li>
</ol>
<ul>
<li>함수를 하위 컴퍼넌트에 전달해 준다.</li>
</ul>
<pre><code>  class App extends Component {
    render() {
      return (
        &lt;div ClassName = &quot;APP&quot;&gt;
          &lt;Subject
            title={this.state.subject.title}
            content={this.state.subject.content}
            onChangePage={
              function(){
                alert(&quot;page chaged&quot;); // 경고창 출력
              }.bind(this);
            }
          &gt;
          &lt;/Subject&gt;
        &lt;/div&gt;
      );
    }
  }
  function Subject() {
      return (
  	    &lt;div&gt;
          &lt;a href=&quot;/&quot; onClick={ function(e) {
            e.preventDefault();
            this.props.onChangePage();  // 상위 컴퍼넌트로 부터 받은 함수 실행
          }
  		&lt;/div&gt;
  	);
  }
</code></pre><ul>
<li>하위 컴퍼넌트를 수정하지 않고 하위 컴퍼넌트의 태그 클릭시 수행할 작업을 변경할 수 있다.</li>
<li>하위 컴퍼넌트에서 상위 컴퍼넌트의 state를 변경할 수 있게 된다.</li>
</ul>
<h2 id="기타">기타</h2>
<ol>
<li>함수형, 클래스형</li>
</ol>
<ul>
<li>react는 함수형 방식과 클래스형 방식으로 작성할 수 있다. 최근에는 함수형 방식을 선호하는 추세이다.</li>
<li>함수형이 클래스형보다 메모리를 덜 사용한다.</li>
</ul>
<ol start="2">
<li>다른 파일 참조</li>
</ol>
<ul>
<li>react에서 다른 파일을 참조할 때에는 &lsquo;import&rsquo;를 사용하며, 확장자가 없으면 &lsquo;.js&rsquo;가 생략된 것으로 본다.<br>
<code>import React, { Component } from &quot;react&quot;</code>는 기본으로 필요하다.</li>
</ul>
<ol start="3">
<li>html에서 예약어로 사용하는 태그들은 &lsquo;synamtic tag&rsquo;라 한다.</li>
</ol>
<ul>
<li>&lsquo;h1&rsquo;, &lsquo;header&rsquo;, &lsquo;nav&rsquo;, &lsquo;article&rsquo; 등이 있다.</li>
</ul>
<ol start="4">
<li><code>export</code> : 특정 객체를 다른 파일에서 import할 수 있도록 한다.<br>
ex) <code>export App</code></li>
</ol>
<h2 id="참조">참조</h2>
<p><a href="https://yuddomack.tistory.com/entry/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EB%AC%B8%EB%B2%95-%EB%B9%84%EA%B5%AC%EC%A1%B0%ED%99%94-%ED%95%A0%EB%8B%B9"target="_blank">자바스크립트 문법</a>
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#array_destructuring"target="_blank">문법 Document</a></p>
</article><section class="article labels"><a class="category" href=/categories/dev/>dev</a><a class="category" href=/categories/basic/>basic</a><a class="tag" href=/tags/react/>react</a><a class="tag" href=/tags/javascript/>javascript</a><a class="tag" href=/tags/web-application/>web application</a></section><section class="article author"><img class="avatar" src="https://d33wubrfki0l68.cloudfront.net/ddf49425628d8aec7523db143916b34ae1641e11/b97e8/images/gopher-side_color.svg" alt><p class="name">gohugo</p><div class="bio">Hugo is one of the most popular open-source static site generators. With its amazing speed and flexibility, Hugo makes building websites fun again.</div><div class="details"><a class="item" href="https://github.com/gohugoio" target="_blank"><span class="iconfont icon-github"></span>&nbsp;gohugoio</a><a class="item" href="https://twitter.com/GoHugoIO" target="_blank"><span class="iconfont icon-twitter"></span>&nbsp;@GoHugoIO</a></div>
</section></div>
<div class="article bottom"><section class="article navigation"><p><a class="link" href="/post/gdb/"><span class="li iconfont icon-article"></span>GDB</a></p><p><a class="link" href="/post/c&#43;&#43;/"><span class="li iconfont icon-article"></span>C++ basic</a></p></section></div></section><section id="footer"><div class="footer-wrap">
    <p class="copyright">©2020 Notepadium.</p>
    <p class="powerby"><span>Powered by </span><a href="https://gohugo.io" 
        target="_blank">Hugo</a><span> and the </span><a href="https://themes.gohugo.io/hugo-notepadium/" 
        target="_blank">Notepadium</a></p>
</div></section></body>

</html>