<!DOCTYPE html>
<html lang="en"><meta charset="utf-8"><meta name="generator" content="Hugo 0.87.0" /><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<meta name="color-scheme" content="light dark">
<meta name="supported-color-schemes" content="light dark"><title>Docker&nbsp;&ndash;&nbsp;AsWindBlew</title><link rel="stylesheet" href="/css/core.min.df05809cfa75ea0a430dc942a79e54236823f6be194b5bc34f0c64744ba5a1b55f91020ad551b34b8af7f2ebee758cc8.css" integrity="sha384-3wWAnPp16gpDDclCp55UI2gj9r4ZS1vDTwxkdEulobVfkQIK1VGzS4r38uvudYzI"><meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="Docker" /><body><section id="header">
    <div class="header wrap"><span class="header left-side"><a class="site home" href="/"><span class="site name">AsWindBlew</span></a></span>
        <span class="header right-side"><div class="nav wrap"><nav class="nav"><a class="nav item" href="/categories/">Categories</a><a class="nav item" href="/tags/">Tags</a><a class="nav item" href="/about/">About</a><a class="nav item" href="https://gohugo%2eio/"target="_blank">Hugo</a></nav></div></span></div><div class="site slogan"><span class="title">published by AswinBlue</span></div></section><section id="content"><div class="article-container"><section class="article header">
    <h1 class="article title">Docker</h1><p class="article date">Aug 12, 2021<span class="reading-time"> • 4 minutes to read</span></p></section><article class="article markdown-body"><h1 id="docker">Docker</h1>
<ul>
<li>리눅스 커널의 cgroups와 namespace에 의해 제공되는 기술</li>
<li>가상화 기능의 일종으로, 별도의 OS를 갖지 않아 VM(Virtual Machine) 보다 가볍다.</li>
<li>게스트는 호스트 OS와 자원을 공유한다.</li>
<li>immutable infrastructure : 서비스 운영 환경을 통째로 이미지화 하여 배포하는 형태</li>
</ul>
<h2 id="설치">설치</h2>
<p><a href="https://docs.docker.com/engine/install/ubuntu/#install-using-the-repository"target="_blank">링크 참조</a></p>
<h2 id="실행">실행</h2>
<h3 id="오류-및-각종-이">오류 및 각종 이</h3>
<ol>
<li>is docker daemon running? 에러</li>
</ol>
<ul>
<li><code>service docker status</code> 입력시 docker daemon이 꺼져있는지 확인</li>
<li><code>service docker start</code> 명령으로 daemon 실행
<ul>
<li>만약 명령은 수행되나 켜지지 않는다면 systemctl명령 수행
<ul>
<li><code>systemctl start docker</code> : docker를 daemon으로 실행</li>
<li><code>systemctl enable docker</code> : OS실행시 docker daemon을 기본 실행</li>
</ul>
</li>
<li>systemctl 명령도 안된다면 <code>/lib/systemd/system/docker.service</code> , <code>/lib/systemd/system/docker.socket</code> 이 제대로 있는지 확인하여 설치 여부를 재확인한다. <br>
<a href="https://velog.io/@pop8682/Docker-Cannot-connect-to-the-Docker-daemon-at-unixvarrundocker.sock.-Is-the-docker-daemon-running-%EC%97%90%EB%9F%AC-%ED%95%B4%EA%B2%B0"target="_blank">참조</a></li>
</ul>
</li>
</ul>
<ol start="2">
<li>init 프로세스(PID 1)이 /bin/bash로 실행되지 않을 때, docker 실행 방법<br>
<code>docker run -t -i ubuntu:16.04 /bin/bash</code></li>
</ol>
<h2 id="docker-명령어">docker 명령어</h2>
<ul>
<li>이미지 : 특정 환경을 만들기 위해 세팅된 정보.</li>
<li>컨테이너 : 실행가능한 상태의 프로세스. 이미지를 컨테이너에 담아 실행시킬 수 있다.</li>
</ul>
<h3 id="생성-및-설정">생성 및 설정</h3>
<ul>
<li>버전 확인
<code>docker -v</code></li>
<li>이미지 다운
<code>docker pull &lt;이미지명&gt;[:태그]</code></li>
<li>이미지 생성 : 현재 경로에서 Dockerfile을 찾아 그 안의
<code>docker build -t &lt;이미지명&gt;</code></li>
<li>설치된 도커 이미지 확인
<code>docker images</code></li>
</ul>
<h3 id="실행-1">실행</h3>
<ul>
<li>컨테이너 생성, 실행하지 않고 정지
<code>docker create [옵션] &lt;이미지명&gt;[:태그]</code></li>
<li>컨테이너 실행 후 CLI 접속
<code>docker attach &lt;컨테이너 id 또는 이름&gt;</code></li>
<li>컨테이너 실행. 지정된 작업이 수행된다.
<code>docker start &lt;이미지명&gt;</code></li>
<li>이미지 다운받아 실행
<code>docker run &lt;이미지명&gt;</code></li>
<li>환경변수 설정
<code>docker run -e &lt;환경변수=설정값&gt;</code></li>
</ul>
<h4 id="옵션">옵션</h4>
<ul>
<li>이미지 다운받아 실행 후 CLI 접속
<code>docker run -it &lt;이미지명&gt;</code></li>
<li>컨테이너 실행시 이름 지정
<code>docker run --name &lt;컨테이너명&gt; &lt;이미지명&gt;</code></li>
<li>디렉터리 연결
<code>docker run -v &lt;로컬경로&gt;:&lt;컨테이너 내부 경로&gt; &lt;이미지명&gt;</code></li>
<li>포트 연결
<code>docker run -p &lt;로컬포트&gt;:&lt;컨테이너 포트&gt; &lt;이미지명&gt;</code></li>
<li>백그라운드 실행
<code>docker run -d &lt;이미지명&gt;</code></li>
<li>프로세스 종료시 컨테이너 자동 삭제
<code>docker run -rm &lt;이미지명&gt;</code></li>
</ul>
<h3 id="관리">관리</h3>
<ul>
<li>실행중인 컨테이너 확인
<code>docker ps</code></li>
<li>일시중지
<code>docker container pause &lt;컨테이너명&gt;</code></li>
<li>일시중지 해제
<code>docker container unpause &lt;컨테이너명&gt;</code></li>
<li>컨테이너 삭제
<code>docker rm &lt;컨테이너 id 또는 이름&gt;</code></li>
<li>모든 컨테이너 삭제
<code>docker rm</code>docker ps -a -q<code> </code></li>
<li>볼륨까지 같이 삭제
<code>docker rm -v &lt;컨테이너 id 또는 이름&gt;</code></li>
<li>이미지 삭제
<code>docker rmi [옵션] &lt;이미지 id&gt;</code></li>
<li>컨테이너 내부에서 커맨드라인을 수행하도록 외부에서 입력
` docker exec [옵션] &lt;컨테이너 id 또는 이름&gt; &lt;커맨드&gt;</li>
<li>컨테이너 실행 후 지정된 명령어 수행
<code>docker exec -it &lt;컨테이너 id 또는 이름&gt; [명령어]</code></li>
<li>백그라운드 실행중인 도커 로그 확인
<code> docker logs -f &lt;컨테이너 id 또는 이름&gt;</code></li>
</ul>
<h2 id="dockerfile">Dockerfile</h2>
<ul>
<li>FROM &lt;이미지명&gt; : 이미 생성된 이미지에 덧붙여서 아래 내용을 수행, import와 비슷한 느낌</li>
<li>MAINTAINER : 메인테이너 정보</li>
<li>WORKDIR : 명령어를 실행할 위치 설멍, 리눅스 cd에 해당</li>
<li>VOLUME [&ldquo;경로1&rdquo;, &ldquo;경로2&rdquo;, &hellip;]: run의 -v 옵션과 유사하지만, docker가 임의로 생성한 디렉터리에 volume을 연결한다. 이는 docker volume 명령어로 관리 가능하지만, 컨테이너가 삭제되고 나면 직접 접근하기 힘들다.</li>
<li>ADD &lt;DIR_SOURCE&gt; &lt;DIR_DEST&gt;: 현재 이미지의 파일들을 내부 이미지의 특정 디렉터리에 복사. 이미지 안에 해당 경로가 없으면 생성하여 추가</li>
<li>RUN &lt;명령어&gt; : 컨테이너가 이미지를 실행하기 전 수행할 쉘 명령어</li>
<li>CMD &lt;명령&gt; : 실행하고 나서 수행할 명령어, 쉘을 불러 실행한다.</li>
<li>CMD [&ldquo;인자 1&rdquo;, &ldquo;인자 2&rdquo;, &hellip;] : 쉘 없이 명령 실행. &lsquo;[]&rsquo; 안에 문자열 배열로 치환해 넘겨주는 형태</li>
<li>EXPOSE : 외부와 연결할 포트, 컨테이너 실행시 -p 옵션을 사용하기 위해 설정해 두어야 함.</li>
<li>ARG &lt;옵션&gt; : 설정 옵션들을 정의</li>
<li>ENV &lt;환경변수&gt; : 환경변수 설정</li>
</ul>
<h2 id="dockerignore">.dockerignore</h2>
<ul>
<li>Docker 이미지 생성시 들어가지 않을 파일들을 지정 가능</li>
</ul>
<h2 id="docker-compose">docker-compose</h2>
<ul>
<li>각각의 Dockerfile들을 묶어 하나의 시스템을 구성하는 도구</li>
<li>docker 실행시 명령어를 미리 작성해 놓은 스크립트라고 보면 된다.</li>
<li><code>docker-compose up</code> 명령으로 docker-compose 파일 빌드 가능. 하위 경로에 Dockerfile들이 각각의 서비스에 해당됨</li>
</ul>
<pre><code>version: '3' 				// 도커 컴퍼즈 버전 3이상 요구
	services: 				// 서비스 내용들이 아래에 옴
		service1: 			// 서비스 이름으로, 마음대로 정의 가능
			build: ./S1 		// docker-compose 파일로부터 경로를 지정
			volumes:
				- ./S1:/home/root 	//	docker run -v 옵션 적용과 동일
			ports:
				- &quot;1234:1234&quot;		// docker run -p 옵션 적용과 동일
			environment:
				- DEBUG_LEVEL=debug	//	환경변수 설정 가능
			links: // docker-compose 3부터는 필요없어진 기능, 네트워크 연결을 위해 사용
				- service2
		service2: 			// 또다른 서비스, 위와 같이 작성 가능

		...
</code></pre></article><section class="article labels"><a class="category" href=/categories/dev/>dev</a><a class="tag" href=/tags/docker/>docker</a></section><section class="article author"><img class="avatar" src="https://d33wubrfki0l68.cloudfront.net/ddf49425628d8aec7523db143916b34ae1641e11/b97e8/images/gopher-side_color.svg" alt><p class="name">gohugo</p><div class="bio">Hugo is one of the most popular open-source static site generators. With its amazing speed and flexibility, Hugo makes building websites fun again.</div><div class="details"><a class="item" href="https://github.com/gohugoio" target="_blank"><span class="iconfont icon-github"></span>&nbsp;gohugoio</a><a class="item" href="https://twitter.com/GoHugoIO" target="_blank"><span class="iconfont icon-twitter"></span>&nbsp;@GoHugoIO</a></div>
</section></div>
<div class="article bottom"><section class="article navigation"><p><a class="link" href="/post/cmake/"><span class="li iconfont icon-article"></span>CMake</a></p><p><a class="link" href="/post/json_c&#43;&#43;/"><span class="li iconfont icon-article"></span>Json in C++</a></p></section></div></section><section id="footer"><div class="footer-wrap">
    <p class="copyright">©2020 Notepadium.</p>
    <p class="powerby"><span>Powered by </span><a href="https://gohugo.io" 
        target="_blank">Hugo</a><span> and the </span><a href="https://themes.gohugo.io/hugo-notepadium/" 
        target="_blank">Notepadium</a></p>
</div></section></body>

</html>